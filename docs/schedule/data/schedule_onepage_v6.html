<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CRT Schedule (One Page Print) — v6 (4 Quarters, ORDERED rings, Per-Quarter Fit + Width-Comp, Tightened)</title>
<style>
  :root{
    --fg:#111;
    --muted:#666;
    --border:#d0d0d0;
    --ring:#0b5d47;
    --ringPrint:#000;

    /* layout */
    --gutter: 0.10in;
    --foldSafe: 0.04in;

    /* tighten knobs */
    --fitPadPx: 6;        /* reserved pixels inside each quarter (prevents border clip) */
    --fitSafety: 0.992;   /* tiny print rounding safety */
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    color:var(--fg);
    background:#fff;
  }

  /* Screen preview as a single Letter page */
  .page{
    width: 8.5in;
    height: 11in;
    padding: 0.25in;
    margin: 12px auto;
    background:#fff;
    overflow:hidden;
  }
  @media print{
    body{background:#fff;}
    .page{
      width:auto;
      height:auto;
      padding:0;
      margin:0;
      overflow:visible;
    }
  }

  .topbar{
    display:flex;
    align-items:flex-end;
    justify-content:space-between;
    gap:10px;
    padding:0 0 6px 0;
  }
  .title{font-weight:900; font-size:14px; line-height:1.1;}
  .subtitle{color:var(--muted); font-size:10px; margin-top:2px;}
  .controls{display:flex; align-items:center; gap:8px; flex-wrap:wrap;}
  .btn{
    border:1px solid var(--border);
    background:#fff;
    padding:3px 10px;
    font-size:12px;
    border-radius:6px;
    cursor:pointer;
  }
  .hint{
    font-size:10px;
    color:var(--muted);
    margin-left:6px;
    white-space:nowrap;
  }

  /* ===========================
     Shared ring/group styling
     =========================== */
  .ring{
    border:1px solid #000;
    width:100%;
    max-width:100%;
  }
  .ring-head{
    background:var(--ring);
    color:#fff;
    padding:4px 6px;
    font-weight:900;
    font-size:10px;
    letter-spacing:.02em;
  }

  .group.has-team{ background: rgb(204 204 204 / 43%); }
  .group.has-team .group-head{ padding-bottom:1px; padding-top:4px; }

  .gdisplay{
    font-size:11px;
    font-weight:600;
    text-align:right;
    text-transform: uppercase;
    margin-bottom:-6px;
    margin-right: 20px;
    margin-left: 10px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .gname{
    font-weight:900;
    font-size:10px;
    line-height:1.1;
    text-align:left;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
    display:none;
  }

  .solid{ border-top:0px solid #000; margin:0; }
  .class-list{ padding:3px 6px 4px 6px; border-bottom:1px solid #8e8c8c; }

  .c{
    display:grid;
    grid-template-columns:46px 1fr;
    column-gap:6px;
    line-height:1.05;
    padding:2px 0;
  }
  .t{ font-weight:600; font-size:9px; white-space:nowrap; }
  .n{ font-size:9px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .muted{ color:var(--muted); }
  .err{ white-space:pre-wrap; color:#b00020; padding:12px; font-size:12px; }

  /* ===========================
     v6 pamphlet layout (YOUR RULES)
     =========================== */

  /* 1 full page full-container */
  .sheet{
    height:100%;
    width:100%;
    display:flex;
    flex-direction:column;
    gap: var(--gutter);
    min-height:0;
    min-width:0;
  }

  /* create 2 half-containers -- vertically 100% width, split height 50/50 */
  .row{
    flex: 1 1 0;
    width:100%;
    display:grid;
    grid-template-columns: 1fr 1fr; /* split again to quarter-containers (50/50) */
    gap: var(--gutter);
    min-height:0;
    min-width:0;
    align-items:stretch;
  }

  /* each quarter-container: 100% height/width, flex align top, stretch width */
  .cell{
    width:100%;
    min-width:0;
    min-height:0;
    overflow:hidden;
    position:relative;
    padding: var(--foldSafe);

    display:flex;
    align-items:flex-start;
    justify-content:flex-start;
  }

  /* content wrapper: stretch width; we scale per quarter, but keep visual width full via JS width-comp */
  .cell-inner{
    width:100%;
    max-width:none;
    transform-origin: top left;
    will-change: transform;
    flex: 0 0 auto;
  }

  .stack{
    width:100%;
    max-width:100%;
    display:flex;
    flex-direction:column;
    gap:2px;
    align-items:stretch;
    justify-content:flex-start; /* push content to top */
    min-width:0;
  }

  /* Print rules */
  @media print{
    @page{ size: Letter; margin: 0.25in; }

    /* hide title/subtitle/topbar in print */
    .topbar{ display:none !important; }
    .controls{ display:none !important; }

    /* deterministic printable content box:
       Letter (8.5x11) with 0.25in margins => 8.0in x 10.5in */
    .sheet{
      width: 8in;
      height: 10.5in;
    }

    body{-webkit-print-color-adjust: exact; print-color-adjust: exact;}
    .ring-head{ background:var(--ringPrint); }
    .group.has-team, .ring-head{
      -webkit-print-color-adjust: exact;
      print-color-adjust: exact;
    }
  }
</style>
</head>
<body>
  <div class="page">
    <div class="topbar">
      <div>
        <div class="title" id="title">Schedule</div>
        <div class="subtitle" id="subtitle"></div>
      </div>
      <div class="controls">
        <button class="btn" onclick="window.print()">Print</button>
        <span class="hint" id="modeHint">Pamphlet mode • ordered quarters • per-quarter fit • top row flipped</span>
      </div>
    </div>

    <!-- Spec positioning:
         TOP ROW:   3 | 2   (flip after render)
         BOTTOM:    4 | 1   (normal)
    -->
    <div class="sheet" id="sheet">
      <div class="row" id="rowTop">
        <div class="cell" id="q3"><div class="cell-inner" id="inner3"><div class="stack" id="stack3"></div></div></div>
        <div class="cell" id="q2"><div class="cell-inner" id="inner2"><div class="stack" id="stack2"></div></div></div>
      </div>
      <div class="row" id="rowBot">
        <div class="cell" id="q4"><div class="cell-inner" id="inner4"><div class="stack" id="stack4"></div></div></div>
        <div class="cell" id="q1"><div class="cell-inner" id="inner1"><div class="stack" id="stack1"></div></div></div>
      </div>
    </div>
  </div>

<script>
  // v6 fixes:
  // 1) RINGS ARE SORTED AND STAY IN SORT ORDER.
  // 2) QUARTERS ARE PLANNED "WISELY" WITHOUT SPLITTING RINGS:
  //    - we do an ORDERED 4-way partition (contiguous ranges) to balance total height/rows.
  // 3) EACH QUARTER SCALES INDEPENDENTLY.
  // 4) FULL-WIDTH VISUAL FILL EVEN WHEN SCALED:
  //    - apply scale(s) + width compensation (100/s)% so it stays visually 100% width.
  // 5) TOP ROW flips after fit; bottom stays as-is.
  // 6) Tightened to prevent 1px border spill (pad + safety).

  const qs = new URLSearchParams(location.search);
  const hashKey = (location.hash || "").replace(/^#/, "").trim();

  function resolveDataUrl(){
    const q = qs.get("data");
    if(q) return q;
    if(/^\d+\-\d{8}$/.test(hashKey)) return `${hashKey}.json`;
    return "docs/schedule/data/print/schedule.json";
  }

  const esc = (s)=>String(s??"").replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
  const toInt = (v)=>{ const n = Number(v); return Number.isFinite(n) ? n : null; };
  const clamp = (min,v,max)=> Math.max(min, Math.min(max, v));

  function normRollup(s){
    const raw = String(s ?? "").trim();
    if(!raw) return "";
    const parts = raw.split(",").map(x=>x.trim()).filter(Boolean);
    const out = [];
    const seen = new Set();
    for(const p of parts){
      const k = p.toLowerCase();
      if(seen.has(k)) continue;
      seen.add(k);
      out.push(p);
    }
    return out.join(", ");
  }

  function normTimeKey(s){
    return String(s ?? "").trim().replace(/\s+/g, " ").toUpperCase();
  }

  async function fetchJson(url){
    const res = await fetch(url, {cache:"no-store"});
    const txt = await res.text();
    if(!res.ok) throw new Error(`Fetch failed ${res.status} for ${url}: ${txt.slice(0,200)}`);
    try { return JSON.parse(txt); }
    catch(e){ throw new Error(`Bad JSON in ${url}: ${txt.slice(0,200)}`); }
  }

  function groupBy(arr, keyFn){
    const m = new Map();
    for(const it of arr){
      const k = keyFn(it);
      if(!m.has(k)) m.set(k, []);
      m.get(k).push(it);
    }
    return m;
  }

  function setHeaderFromFirst(rows){
    const first = rows[0] || {};
    const showId = first.show_id ?? first.showId ?? "";
    const reportTitle = first.show_days_report_title ?? first.show_report_title ?? (showId ? `Show ${showId}` : "Schedule");
    const displayDate = first.show_days_display_date ?? first.show_display_date ?? first.show_date ?? first.showDate ?? "";
    const showDayKey = first.show_day_key ?? first.showDayKey ?? first.show_days ?? first.showDays ?? "";

    document.getElementById("title").textContent = reportTitle;
    const subParts = [];
    if(displayDate) subParts.push(String(displayDate));
    if(showId !== "" && showId !== null && showId !== undefined) subParts.push(`show_id ${showId}`);
    if(showDayKey) subParts.push(String(showDayKey));
    document.getElementById("subtitle").textContent = subParts.join("   •   ");
  }

  // weights used to estimate vertical footprint (balancing)
  const RING_HEAD_WEIGHT = 1.0;
  const GROUP_HEAD_WEIGHT = 0.5;
  const CLASS_ROW_WEIGHT = 1.0;

  function buildRingsWithRowCounts(rows){
    // group rings, then SORT by ring_number
    const rings = Array.from(
      groupBy(rows, r => String(r.ring_number ?? r.ringNumber ?? "9999")).entries()
    )
    .map(([k, items]) => ({ ring_number: toInt(k) ?? 9999, items }))
    .sort((a,b)=>a.ring_number - b.ring_number);

    const out = [];

    for(const ring of rings){
      const items0 = ring.items[0] || {};
      const ringTitle = items0.ring_name ?? items0.ringName ?? items0.ring_nickname ?? items0.ringNickname ?? "Ring";

      const groups = Array.from(
        groupBy(ring.items, r => String(r.class_group_id ?? r.classGroupId ?? "")).entries()
      )
      .map(([gid, items]) => {
        const seq = toInt(items[0]?.class_group_sequence ?? items[0]?.classGroupSequence ?? 9999) ?? 9999;
        const gname = items[0]?.group_group_name ?? items[0]?.group_name ?? items[0]?.groupName ?? "Group";
        const gd = normRollup(items.map(x => x.group_display).filter(Boolean).join(", "));
        return { gid, seq, gname, gdisplay: gd, items };
      })
      .sort((a,b)=>a.seq - b.seq);

      let weightedRows = 0;
      weightedRows += RING_HEAD_WEIGHT;

      const sec = document.createElement("section");
      sec.className = "ring";
      sec.innerHTML = `<div class="ring-head">${esc(ringTitle)}</div>`;

      for(const g of groups){
        weightedRows += GROUP_HEAD_WEIGHT;

        const classes = g.items.slice().sort((a,b)=>{
          const an = toInt(a.class_number ?? a.classNumber ?? 999999) ?? 999999;
          const bn = toInt(b.class_number ?? b.classNumber ?? 999999) ?? 999999;
          return an - bn;
        });

        let lastTimeKey = null;
        let cl = "";
        for(const c of classes){
          weightedRows += CLASS_ROW_WEIGHT;

          const timeRaw = String(c.start_display ?? c.startDisplay ?? "").trim();
          const timeKey = normTimeKey(timeRaw);
          const showTime = (timeKey && timeKey !== lastTimeKey);
          if(timeKey) lastTimeKey = timeKey;

          const num = c.class_number ?? c.classNumber;
          const name = c.class_name ?? c.className ?? c.name ?? "";
          const label = (num !== undefined && num !== null && String(num).trim() !== "" && String(num) !== "0")
            ? `${num} - ${name}`.trim()
            : String(name).trim();

          cl += `<div class="c"><div class="t">${esc(showTime ? timeRaw : "")}</div><div class="n">${esc(label)}</div></div>`;
        }

        const gDiv = document.createElement("div");
        gDiv.className = `group${g.gdisplay ? " has-team" : ""}`;
        gDiv.innerHTML = `
          <div class="group-head">
            ${g.gdisplay ? `<div class="gdisplay">${esc(g.gdisplay)}</div>` : ``}
            <div class="gname">${esc(g.gname)}</div>
          </div>
          <div class="solid"></div>
          <div class="class-list">${cl || `<div class="muted">No classes scheduled.</div>`}</div>
        `;
        sec.appendChild(gDiv);
      }

      out.push({
        ring_number: ring.ring_number,
        el: sec,
        weightedRows
      });
    }

    return out;
  }

  function clearStacks(){
    for(const id of ["stack1","stack2","stack3","stack4"]){
      const el = document.getElementById(id);
      if(el) el.innerHTML = "";
    }
    for(const id of ["inner1","inner2","inner3","inner4"]){
      const inner = document.getElementById(id);
      if(inner){
        inner.style.transform = "scale(1)";
        inner.style.width = "100%";
        inner.style.maxWidth = "none";
        inner.style.transformOrigin = "top left";
      }
    }
    const rowTop = document.getElementById("rowTop");
    if(rowTop) rowTop.style.transform = "none";
  }

  // ORDERED 4-way partition (contiguous segments) minimizing the maximum segment sum.
  // Rings cannot be split; ring order preserved.
  function partitionOrdered4(rings){
    const n = rings.length;
    const k = 4;
    if(n === 0) return [[],[],[],[]];

    const w = rings.map(r => Number(r.weightedRows) || 0);
    const prefix = new Array(n+1).fill(0);
    for(let i=0;i<n;i++) prefix[i+1] = prefix[i] + w[i];

    const segSum = (i,j) => prefix[j] - prefix[i]; // [i, j)

    // dp[t][i] = minimal possible max segment sum when partitioning first i items into t segments
    const dp = Array.from({length:k+1}, ()=> new Array(n+1).fill(Infinity));
    const cut = Array.from({length:k+1}, ()=> new Array(n+1).fill(-1));

    dp[0][0] = 0;

    for(let t=1; t<=k; t++){
      for(let i=1; i<=n; i++){
        // j is previous cut position
        // require at least one item per segment when possible
        const jMin = t-1;
        const jMax = i-1;
        for(let j=jMin; j<=jMax; j++){
          if(!Number.isFinite(dp[t-1][j])) continue;
          const maxHere = Math.max(dp[t-1][j], segSum(j,i));
          if(maxHere < dp[t][i]){
            dp[t][i] = maxHere;
            cut[t][i] = j;
          }
        }
      }
    }

    // backtrack cut points
    let i = n;
    const ranges = [];
    for(let t=k; t>=1; t--){
      let j = cut[t][i];
      if(j < 0){
        // fallback: put everything into last segment if something weird happens
        ranges.length = 0;
        ranges.push([0,n]);
        break;
      }
      ranges.push([j,i]);
      i = j;
    }
    ranges.reverse();

    // If n < 4, pad empty leading segments so we always return 4 buckets
    while(ranges.length < 4) ranges.unshift([0,0]);

    const buckets = ranges.map(([a,b]) => rings.slice(a,b));
    // Guarantee exactly 4
    while(buckets.length < 4) buckets.push([]);
    return buckets.slice(0,4);
  }

  function placeBucketsOrdered(buckets){
    // buckets are in RING SORT ORDER:
    // bucket[0] = earliest rings, bucket[3] = latest rings
    //
    // mapping to your physical layout numbers:
    // Q1 is bottom-right, Q2 is top-right, Q3 is top-left, Q4 is bottom-left
    const map = [
      {bucket: 0, stackId:"stack1"}, // Q1 bottom-right
      {bucket: 1, stackId:"stack2"}, // Q2 top-right
      {bucket: 2, stackId:"stack3"}, // Q3 top-left
      {bucket: 3, stackId:"stack4"}, // Q4 bottom-left
    ];
    for(const m of map){
      const stack = document.getElementById(m.stackId);
      const frag = document.createDocumentFragment();
      for(const r of buckets[m.bucket]) frag.appendChild(r.el);
      stack.appendChild(frag);
    }
  }

  // per-quarter min/max (independent)
  const SCALE_LIMITS = {
    q1: { min: 0.50, max: 1.00 },
    q2: { min: 0.50, max: 1.00 },
    q3: { min: 0.50, max: 1.00 },
    q4: { min: 0.50, max: 1.00 },
  };

  function cssVarNumberPx(name, fallback){
    const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    const n = Number(v);
    return Number.isFinite(n) ? n : fallback;
  }
  function cssVarNumber(name, fallback){
    const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    const n = Number(v);
    return Number.isFinite(n) ? n : fallback;
  }

  function measureScaleToFitHeight(cellId, innerId){
    const cell = document.getElementById(cellId);
    const inner = document.getElementById(innerId);
    if(!cell || !inner) return 1;

    const lim = SCALE_LIMITS[cellId] || {min:0.50, max:1.00};

    // reset for accurate measurement
    inner.style.transform = "scale(1)";
    inner.style.width = "100%";
    inner.style.maxWidth = "none";
    inner.style.transformOrigin = "top left";

    const fitPadPx = cssVarNumberPx("--fitPadPx", 6);
    const safety = cssVarNumber("--fitSafety", 0.992);

    const availH = Math.max(0, cell.clientHeight - fitPadPx);
    const needH = inner.scrollHeight || inner.getBoundingClientRect().height;
    if(!needH || !availH) return 1;

    let s = Math.min(1, (availH / needH) * safety);
    s = clamp(lim.min, s, lim.max);
    return s;
  }

  function applyScaleWithWidthComp(innerId, scale){
    const inner = document.getElementById(innerId);
    if(!inner) return;

    const s = Math.max(0.01, scale);

    inner.style.transformOrigin = "top left";
    inner.style.transform = `scale(${s})`;

    // width compensation so VISUAL width stays full:
    inner.style.width = (100 / s) + "%";
    inner.style.maxWidth = "none";
  }

  function flipTopRowAfterFit(){
    const rowTop = document.getElementById("rowTop");
    if(!rowTop) return;
    rowTop.style.transformOrigin = "center center";
    rowTop.style.transform = "rotate(180deg)";
  }

  function summarizeBucket(bucket){
    if(!bucket || bucket.length === 0) return "—";
    const a = bucket[0].ring_number;
    const b = bucket[bucket.length-1].ring_number;
    const sum = bucket.reduce((s,x)=>s+(Number(x.weightedRows)||0),0);
    return `R${a}–R${b} (${sum.toFixed(1)})`;
  }

  function setHint(scales, buckets){
    const hint = document.getElementById("modeHint");
    if(!hint) return;
    const min = Math.min(scales.s1, scales.s2, scales.s3, scales.s4);
    const max = Math.max(scales.s1, scales.s2, scales.s3, scales.s4);
    hint.textContent =
      `Ordered quarters • width-comp • min ${(min*100).toFixed(0)}% max ${(max*100).toFixed(0)}%` +
      ` • Q1 ${summarizeBucket(buckets[0])} Q2 ${summarizeBucket(buckets[1])} Q3 ${summarizeBucket(buckets[2])} Q4 ${summarizeBucket(buckets[3])}`;
  }

  async function render(){
    const url = resolveDataUrl();
    const rows = await fetchJson(url);

    if(!Array.isArray(rows) || rows.length === 0){
      document.getElementById("stack4").innerHTML = `<div class="muted">No schedule rows.</div>`;
      return;
    }

    setHeaderFromFirst(rows);
    clearStacks();

    const ringsSorted = buildRingsWithRowCounts(rows); // sorted by ring_number
    const buckets = partitionOrdered4(ringsSorted);    // ORDERED contiguous segments
    placeBucketsOrdered(buckets);

    // Let layout settle (must be before measuring heights)
    await new Promise(r => requestAnimationFrame(r));
    await new Promise(r => requestAnimationFrame(r));

    // Fit EACH quarter independently by HEIGHT, then compensate width (per quarter)
    const scales = {
      s1: measureScaleToFitHeight("q1","inner1"),
      s2: measureScaleToFitHeight("q2","inner2"),
      s3: measureScaleToFitHeight("q3","inner3"),
      s4: measureScaleToFitHeight("q4","inner4"),
    };

    applyScaleWithWidthComp("inner1", scales.s1);
    applyScaleWithWidthComp("inner2", scales.s2);
    applyScaleWithWidthComp("inner3", scales.s3);
    applyScaleWithWidthComp("inner4", scales.s4);

    // flip top container AFTER render+fit; bottom stays as-is
    flipTopRowAfterFit();

    setHint(scales, buckets);
  }

  (async function main(){
    await render();
    window.addEventListener("beforeprint", async ()=>{ await render(); });
    window.addEventListener("resize", ()=>{ render().catch(()=>{}); });
  })().catch(err=>{
    const target = document.getElementById("stack4");
    if(target) target.innerHTML = `<div class="err">${esc(String(err && err.stack ? err.stack : err))}</div>`;
  });
</script>
</body>
</html>
