<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<script src="https://cdn.pagesense.io/js/sportdogfood141/cddc7cd656d44f509188052c2686ac15.js"></script>
<title>CRT Schedule (Mobile v4)</title>
<style>
  :root{
    --fg:#111;
    --muted:#666;
    --border:#d0d0d0;
    --ring:#0b5d47;

    --topbar-h: 56px;
    --filterbar-h: 74px;
    --bottom-nav-h: 64px;

    --bg:#fff;
  }
  *{box-sizing:border-box}
  html{scroll-behavior:smooth;}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    color:var(--fg);
    background:var(--bg);
    padding-bottom: calc(var(--bottom-nav-h) + env(safe-area-inset-bottom, 0px));
  }

  /* Sticky top header */
  .topbar{
    position:sticky;
    top:0;
    z-index:20;
    background:rgba(255,255,255,.96);
    backdrop-filter: blur(6px);
    border-bottom:1px solid var(--border);
    padding:10px 12px;
    min-height:var(--topbar-h);
    display:flex;
    flex-direction:column;
    justify-content:center;
    gap:2px;
  }
  .title{font-weight:900; font-size:14px; line-height:1.1;}
  .subtitle{color:var(--muted); font-size:12px; line-height:1.2; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}

  /* Topbar home button */
  .topbar-row{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
  }
  .topbar-text{
    min-width:0;
    display:flex;
    flex-direction:column;
    gap:2px;
  }
  .home-pill{
    flex:0 0 auto;
    height:34px;
    padding:0 14px;
    border-radius:999px;
    border:1px solid var(--border);
    background:#fff;
    color:#111;
    font-size:12px;
    font-weight:900;
    text-decoration:none;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    line-height:1;
  }
  .home-pill:active{
    transform: translateY(1px) scale(0.99);
  }
    /* allow the inner scroller to actually overflow horizontally */
  .filter-row{
    overflow:hidden;
  }

  .filterbar .nav-scroller{
    flex:1 1 auto;
    min-width:0;          /* THIS is the key */
  }

  /* V4: Sticky filterbar (covers topbar when scrolling) */
  .filterbar{
    position:sticky;
    top:0;
    z-index:25;
    background:rgba(255, 255, 255, 0);
    backdrop-filter: blur(6px);
    border-bottom:1px solid var(--border);
    padding:6px 10px 6px 10px;
  }

    /* filter pills styled exactly like bottom nav pills */
  .filterbar .nav-btn{
    border:1px solid var(--border);
    background:#fff;
    color:#111;
  }
  .filterbar .nav-btn.active{
    border-color:#000;
  }

  .filter-row{
    display:flex;
    align-items:center;
    gap:8px;
    margin:4px 0;
  }

  /* (labels removed in markup, keep rule safe) */
  .filter-label{display:none;}

  /* Reuse nav scroller + pills */
  .nav-scroller{
    display:flex;
    gap:8px;
    overflow-x:auto;
    -webkit-overflow-scrolling: touch;
    scrollbar-width:none;
  }
  .nav-scroller::-webkit-scrollbar{display:none;}

  .nav-btn{
    flex:0 0 auto;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    border:1px solid var(--border);
    background:#fff;
    color:#111;
    padding:6px 10px;
    font-size:12px;
    font-weight:600;
    border-radius:999px;
    text-decoration:none;
    white-space:nowrap;
    user-select:none;
    cursor:pointer;
  }
  .nav-btn.active{
    border-color:#000;
  }

  /* Main list */
  main{
    padding:4px 4px 4px 4px;
    display:flex;
    flex-direction:column;
    gap:10px;
  }

  .ring{
    border:1px solid #000;
    border-radius:10px;
    overflow:hidden;
    background:#fff;
    /* anchor offset for sticky topbar + filterbar */
    scroll-margin-top: calc(var(--topbar-h) + var(--filterbar-h) + 10px);
  }
  .ring-head{
    background:var(--ring);
    color:#fff;
    padding:10px 10px;
    font-weight:600;
    font-size:14px;
    letter-spacing:.02em;
  }

  /* highlight groups that have a team (gdisplay present) */
  .group.has-team{
    background: rgba(255, 255, 255, 0.43);
  }

  /* V4: shade by group status */
  .group.has-team[data-status="upcoming"]{
    background: rgba(144 151 205 / 15%);
  }
  .group.has-team[data-status="underway"]{
    background: rgba(118, 219, 155, 0.12);
  }
  .group.has-team[data-status="completed"]{
    background: rgba(228, 228, 228, 0.55);
  }

  .group-head{
    padding:0px 10px 0px 6px;
  }

  /* group_display above group_name */
  .gdisplay{
    font-size:10px;
    font-weight:700;
    text-transform: uppercase;
    white-space:nowrap;
    overflow:hidden;
    margin-bottom:-1px;
    text-overflow:ellipsis;
    text-align:right;
    padding-right: 4px;
    padding-top: 4px;
    position: relative; z-index: 10;
  }
  .gname{
    display:none; /* per spec: gname is hidden */
  }

  .class-list{
    padding:0 10px 6px 10px;
  }

  .c{
    display:grid;
    grid-template-columns:62px 1fr auto; /* time | label | status */
    column-gap:10px;
    align-items:center;
    line-height:1.15;
    padding:8px 0;
    border-bottom:1px solid #eee;
  }
  .c:last-child{border-bottom:none;}
  .t{font-weight:700; font-size:12px; white-space:nowrap;}
  .n{
    font-size:12px;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }

  /* status pill */
  .s{
    font-size:6px;
    font-weight:600;
    text-transform: uppercase;
    white-space:nowrap;
    padding-right: 4px;
  }

  /* ONLY the time highlights when start_display2 is being used */
  .c.time2 .t{
    background: rgb(11 93 71 / 18%);
    padding:2px 6px;
    border-radius:6px;
    font-weight:900;
    justify-self:start;
    width:max-content;
  }

  .muted{color:var(--muted); font-size:12px;}
  .err{white-space:pre-wrap; color:#b00020; padding:12px; font-size:12px; border:1px solid #b00020; border-radius:10px;}

  /* Bottom ring nav */
  .bottom-nav{
    position:fixed;
    left:0; right:0; bottom:0;
    z-index:30;
    background:rgba(255, 255, 255, 0.0);
    backdrop-filter: blur(6px);
    border-top:1px solid var(--border);
    padding:4px 10px calc(10px + env(safe-area-inset-bottom, 0px)) 10px;
  }

  /* Bottom nav pill overrides (dark bar) */
  .bottom-nav .nav-btn{
    border:1px solid var(--border);
    background:#fff;
    color:#111;
  }
  .bottom-nav .nav-btn.active{
    border-color:#000;
  }
</style>
</head>
<body>

<header class="topbar">
  <div class="topbar-row">
    <div class="topbar-text">
      <div class="title" id="title">Schedule</div>
      <div class="subtitle" id="subtitle"></div>
    </div>
    <a class="home-pill" href="https://blog.clearroundtravel.com/schedule/data/schedules.html">Home</a>
  </div>
</header>

<!-- V4: Sticky filters -->
<nav class="filterbar" id="filterBar" aria-label="Schedule Filters">
  <div class="filter-row">
    <div class="nav-scroller" id="horseFilters"></div>
  </div>
  <div class="filter-row">
    <div class="nav-scroller" id="statusFilters"></div>
  </div>
</nav>

<main id="rings"></main>

<nav class="bottom-nav" id="bottomNav">
  <div class="nav-scroller" id="ringNav"></div>
</nav>

<script>
  // Poll the JSON for changes
  const POLL_MS = 6 * 60 * 1000;

  // Your publish cadence (used only for "next:")
  const PUBLISH_INTERVAL_MS = 8 * 60 * 1000;

  const TIMEZONE = "America/New_York";

  // V4 filter state (persist across refresh)
  let activeHorse = "__all__";
  let activeStatus = "__all__";

  const qs = new URLSearchParams(location.search);
  const rawHash = (location.hash || "").replace(/^#/, "").trim();

  let activeIO = null;
  let lastRaw = null;
  let lastLastMod = null;
  let currentDataUrl = null;
  let isRefreshing = false;

  // server-published time (ms) based on Last-Modified header
  let publishedAtMs = null;

  const fmtTimeET = (ms)=>{
    return new Intl.DateTimeFormat("en-US", {
      timeZone: TIMEZONE,
      hour: "numeric",
      minute: "2-digit"
    }).format(new Date(ms));
  };

  const esc = (s)=>String(s??"").replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
  const toInt = (v)=>{ const n = Number(v); return Number.isFinite(n) ? n : null; };

  function normalizeShowDay(v){
    // accepts "20260118" or "2026-01-18"
    const s = String(v ?? "").trim();
    if(!s) return "";
    if(/^\d{8}$/.test(s)) return s;
    const m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if(m) return `${m[1]}${m[2]}${m[3]}`;
    return "";
  }

  function resolveDataUrl(){
    // primary: explicit file
    const q = qs.get("data");
    if(q) return q;

    // build from show_id + show_day
    const showId = (qs.get("show_id") || qs.get("showId") || "").trim();
    const showDayRaw = (qs.get("show_day") || qs.get("showDay") || "").trim();
    const showDay = normalizeShowDay(showDayRaw);
    if(showId && showDay){
      return `${showId}-${showDay}M.json`;
    }

    // back-compat: hash like "200000046-20260118" or "200000046-20260118M" (optional .json)
    if(/^\d+\-\d{8}M?(\.json)?$/i.test(rawHash)){
      let base = rawHash.replace(/\.json$/i, "");
      if(!/M$/i.test(base)) base = base + "M";
      const file = base + ".json";

      const next = new URL(location.href);
      next.searchParams.set("data", file);
      next.hash = "";
      history.replaceState(null, "", next.toString());
      return file;
    }

    return "schedule.json";
  }

  function normRollup(s){
    const raw = String(s ?? "").trim();
    if(!raw) return "";
    const parts = raw.split(",").map(x=>x.trim()).filter(Boolean);
    const out = [];
    const seen = new Set();
    for(const p of parts){
      const k = p.toLowerCase();
      if(seen.has(k)) continue;
      seen.add(k);
      out.push(p);
    }
    return out.join(", ");
  }

  function extractHorseName(groupDisplayPart){
    // "Pedro (11)" -> "Pedro"
    const s = String(groupDisplayPart ?? "").trim();
    if(!s) return "";
    const idx = s.indexOf(" (");
    return (idx > 0 ? s.slice(0, idx) : s).trim();
  }

  function normalizeStatusToken(s){
    const v = String(s ?? "").trim().toLowerCase();
    if(v === "upcoming") return "upcoming";
    if(v === "underway") return "underway";
    if(v === "completed") return "completed";
    return "";
  }

  function computeGroupStatus(items){
    // Priority:
    // 1) any Underway
    // 2) else any Upcoming
    // 3) else all Completed
    // else blank
    let hasUnderway = false;
    let hasUpcoming = false;
    let hasCompleted = false;
    let sawAnyStatus = false;
    let sawNonCompleted = false;

    for(const c of items){
      const s = String(c.status2 ?? "").trim();
      if(!s) continue;
      sawAnyStatus = true;
      if(s === "Underway") hasUnderway = true;
      else if(s === "Upcoming") hasUpcoming = true;
      else if(s === "Completed") hasCompleted = true;
      else sawNonCompleted = true;
      if(s !== "Completed") sawNonCompleted = true;
    }

    if(hasUnderway) return "Underway";
    if(hasUpcoming) return "Upcoming";
    if(sawAnyStatus && hasCompleted && !sawNonCompleted) return "Completed";
    return "";
  }

  async function fetchTextMeta(url){
    const res = await fetch(url, {cache:"no-store"});
    const txt = await res.text();
    if(!res.ok) throw new Error(`Fetch failed ${res.status} for ${url}: ${txt.slice(0,200)}`);
    const lastMod = res.headers.get("last-modified");
    return { txt, lastMod };
  }

  function parseJsonText(txt, urlLabel){
    try { return JSON.parse(txt); }
    catch(e){ throw new Error(`Bad JSON in ${urlLabel}: ${String(txt).slice(0,200)}`); }
  }

  function groupBy(arr, keyFn){
    const m = new Map();
    for(const it of arr){
      const k = keyFn(it);
      if(!m.has(k)) m.set(k, []);
      m.get(k).push(it);
    }
    return m;
  }

  function setHeader(rows){
    const first = rows[0] || {};

    const reportTitle =
      first.show_days_report_title ??
      first.show_report_title ??
      (first.show_id ? `Show ${first.show_id}` : "Schedule");

    const displayDate =
      first.show_days_display_date ??
      first.show_display_date ??
      first.show_date ??
      first.showDate ??
      "";

    document.getElementById("title").textContent = reportTitle;

    const subParts = [];
    if(displayDate) subParts.push(String(displayDate));

    if(publishedAtMs){
      subParts.push(`published: ${fmtTimeET(publishedAtMs)}`);
      subParts.push(`next: ${fmtTimeET(publishedAtMs + PUBLISH_INTERVAL_MS)}`);
    }

    document.getElementById("subtitle").textContent = subParts.join("   â€¢   ");
  }

  function buildRings(rows){
    const rings = Array.from(groupBy(rows, r => String(r.ring_number ?? r.ringNumber ?? "9999")).entries())
      .map(([k, items]) => ({ ring_number: toInt(k) ?? 9999, items }))
      .sort((a,b)=>a.ring_number - b.ring_number);

    const ringEls = [];

    for(let i=0;i<rings.length;i++){
      const ring = rings[i];
      const items0 = ring.items[0] || {};
      const ringTitle = items0.ring_name ?? items0.ringName ?? items0.ring_nickname ?? items0.ringNickname ?? "Ring";

      const ringId = (Number.isFinite(ring.ring_number) && ring.ring_number !== 9999)
        ? `ring-${ring.ring_number}`
        : `ring-x${i+1}`;

      const groups = Array.from(groupBy(ring.items, r => String(r.class_group_id ?? r.classGroupId ?? "")).entries())
        .map(([gid, items]) => {
          const seq = toInt(items[0]?.class_group_sequence ?? items[0]?.classGroupSequence ?? 9999) ?? 9999;
          const gname = items[0]?.group_group_name ?? items[0]?.group_name ?? items[0]?.groupName ?? "Group";
          const gd = normRollup(items.map(x => x.group_display).filter(Boolean).join(", "));
          const gstatus = computeGroupStatus(items);
          return { gid, seq, gname, gdisplay: gd, gstatus, items };
        })
        .sort((a,b)=>a.seq - b.seq);

      const sec = document.createElement("section");
      sec.className = "ring";
      sec.id = ringId;
      sec.dataset.ringTitle = String(ringTitle);

      sec.innerHTML = `<div class="ring-head">${esc(ringTitle)}</div>`;

      for(const g of groups){
        const classes = g.items.slice().sort((a,b)=>{
          const an = toInt(a.class_number ?? a.classNumber ?? 999999) ?? 999999;
          const bn = toInt(b.class_number ?? b.classNumber ?? 999999) ?? 999999;
          return an - bn;
        });

        let cl = "";
        let lastTime = null;

        for(const c of classes){
          const sd1 = String(c.start_display ?? c.startDisplay ?? "").trim();
          const sd2 = String(c.start_display2 ?? c.startDisplay2 ?? "").trim();

          const usingTime2 = !!(sd2 && (!sd1 || sd2 !== sd1));
          const displayTime = usingTime2 ? sd2 : (sd1 || sd2);

          const showTime = (displayTime && displayTime !== lastTime);
          if(showTime) lastTime = displayTime;

          const num = c.class_number ?? c.classNumber;
          const name = c.class_name ?? c.className ?? c.name ?? "";
          const label = (num !== undefined && num !== null && String(num).trim() !== "" && String(num) !== "0")
            ? `${num} - ${name}`.trim()
            : String(name).trim();

          const status2 = String(c.status2 ?? "").trim();
          const statusHtml = status2 ? `<div class="s">${esc(status2)}</div>` : `<div></div>`;

          cl += `
            <div class="c${usingTime2 ? " time2" : ""}">
              <div class="t">${esc(showTime ? displayTime : "")}</div>
              <div class="n">${esc(label)}</div>
              ${statusHtml}
            </div>
          `;
        }

        const horses = [];
        if(g.gdisplay){
          const parts = String(g.gdisplay).split(",").map(x=>x.trim()).filter(Boolean);
          for(const p of parts){
            const hn = extractHorseName(p);
            if(hn) horses.push(hn);
          }
        }
        const horsesNorm = Array.from(new Set(horses.map(h=>h.toLowerCase()))).join("|");
        const statusNorm = normalizeStatusToken(g.gstatus);

        const gDiv = document.createElement("div");
        const hasTeam = !!g.gdisplay;

        gDiv.className = `group${hasTeam ? " has-team" : ""}`;
        if(hasTeam){
          if(horsesNorm) gDiv.dataset.horses = horsesNorm;
          if(statusNorm) gDiv.dataset.status = statusNorm;
        }

        gDiv.innerHTML = `
          <div class="group-head">
            ${g.gdisplay ? `<div class="gdisplay">${esc(g.gdisplay)}</div>` : ``}
            <div class="gname">${esc(g.gname)}</div>
          </div>
          <div class="class-list">${cl || `<div class="muted">No classes scheduled.</div>`}</div>
        `;

        sec.appendChild(gDiv);
      }

      ringEls.push(sec);
    }

    return ringEls;
  }

  function buildBottomNav(ringEls){
    const nav = document.getElementById("ringNav");
    nav.innerHTML = "";

    for(const sec of ringEls){
      const a = document.createElement("a");
      a.className = "nav-btn";
      a.href = `#${sec.id}`;
      a.textContent = sec.dataset.ringTitle || "Ring";
      nav.appendChild(a);
    }
  }

  function syncBottomNavHeight(){
    const bottom = document.getElementById("bottomNav");
    const h = bottom ? bottom.getBoundingClientRect().height : 64;
    document.documentElement.style.setProperty("--bottom-nav-h", Math.ceil(h) + "px");
  }

  function syncFilterBarHeight(){
    const fb = document.getElementById("filterBar");
    const h = fb ? fb.getBoundingClientRect().height : 74;
    document.documentElement.style.setProperty("--filterbar-h", Math.ceil(h) + "px");
  }

  function destroyActiveRingObserver(){
    if(activeIO){
      try { activeIO.disconnect(); } catch(e){}
      activeIO = null;
    }
  }

  function setupActiveRingObserver(){
    destroyActiveRingObserver();

    const buttons = Array.from(document.querySelectorAll("#ringNav .nav-btn"));
    const sections = Array.from(document.querySelectorAll("section.ring"))
      .filter(sec => sec.style.display !== "none"); // ignore hidden rings

    const btnById = new Map();
    for(const b of buttons){
      const id = (b.getAttribute("href") || "").replace(/^#/, "");
      btnById.set(id, b);
    }

    const clearActive = ()=>buttons.forEach(b=>b.classList.remove("active"));

    const filterH = (document.getElementById("filterBar")?.getBoundingClientRect().height || 74);
    const bottomH = (document.getElementById("bottomNav")?.getBoundingClientRect().height || 64);

    activeIO = new IntersectionObserver((entries)=>{
      const vis = entries
        .filter(e=>e.isIntersecting)
        .sort((a,b)=> (b.intersectionRatio - a.intersectionRatio));

      if(!vis.length) return;

      const id = vis[0].target.id;
      clearActive();
      const btn = btnById.get(id);
      if(btn) btn.classList.add("active");
    }, {
      root: null,
      rootMargin: `-${filterH + 10}px 0px -${bottomH + 10}px 0px`,
      threshold: [0.2, 0.35, 0.5, 0.65]
    });

    sections.forEach(sec=>activeIO.observe(sec));
  }

  /* ----------------------------
     FILTERS
  -----------------------------*/

  function collectFilterCandidatesFromDOM(){
    const horseSet = new Set();

    const groups = Array.from(document.querySelectorAll(".group.has-team"));
    for(const g of groups){
      const horses = String(g.dataset.horses ?? "").trim();
      if(horses){
        horses.split("|").map(x=>x.trim()).filter(Boolean).forEach(h=>horseSet.add(h));
      }
    }

    const horsesList = Array.from(horseSet)
      .map(h=>({ key: h, label: h }))
      .sort((a,b)=>a.label.localeCompare(b.label));

    return { horsesList };
  }

  function prettyHorseLabel(h){
    const s = String(h||"").trim();
    if(!s) return "";
    return s.charAt(0).toUpperCase() + s.slice(1);
  }

  function prettyStatusLabel(k){
    const t = String(k||"").toLowerCase();
    if(t === "upcoming") return "Upcoming";
    if(t === "underway") return "Underway";
    if(t === "completed") return "Completed";
    return k;
  }

  function makeFilterButton({text, value, active, onClick}){
    const b = document.createElement("button");
    b.type = "button";
    b.className = "nav-btn" + (active ? " active" : "");
    b.textContent = text;
    b.dataset.value = value;
    b.addEventListener("click", onClick);
    return b;
  }

  function updateFilterUI(){
    for(const b of Array.from(document.querySelectorAll("#horseFilters .nav-btn"))){
      b.classList.toggle("active", b.dataset.value === activeHorse);
    }
    for(const b of Array.from(document.querySelectorAll("#statusFilters .nav-btn"))){
      b.classList.toggle("active", b.dataset.value === activeStatus);
    }
  }

  function applyFilters(){
    const groups = Array.from(document.querySelectorAll(".group.has-team"));

    const needHorse = activeHorse !== "__all__";
    const needStatus = activeStatus !== "__all__";

    const horseKey = String(activeHorse).toLowerCase();
    const statusKey = String(activeStatus).toLowerCase();

    // 1) Hide/show groups
    for(const g of groups){
      let ok = true;

      if(needHorse){
        const horses = String(g.dataset.horses ?? "");
        ok = ok && horses.split("|").map(x=>x.trim()).includes(horseKey);
      }

      if(needStatus){
        const st = String(g.dataset.status ?? "").trim().toLowerCase();
        ok = ok && (st === statusKey);
      }

      g.style.display = ok ? "" : "none";
    }

    // 2) Hide/show entire rings + bottom-nav buttons
    const ringSections = Array.from(document.querySelectorAll("section.ring"));
    const ringNavBtns = Array.from(document.querySelectorAll("#ringNav .nav-btn"));

    const navById = new Map();
    for(const b of ringNavBtns){
      const id = (b.getAttribute("href") || "").replace(/^#/, "");
      if(id) navById.set(id, b);
    }

    for(const sec of ringSections){
      const teamGroups = Array.from(sec.querySelectorAll(".group.has-team"));
      const anyVisible = teamGroups.some(g => g.style.display !== "none");

      sec.style.display = anyVisible ? "" : "none";

      const btn = navById.get(sec.id);
      if(btn) btn.style.display = anyVisible ? "" : "none";
    }

    // 3) Rebuild active observer
    setupActiveRingObserver();
  }

  function renderFilters(){
    const { horsesList } = collectFilterCandidatesFromDOM();

    const horseWrap = document.getElementById("horseFilters");
    const statusWrap = document.getElementById("statusFilters");

    horseWrap.innerHTML = "";
    statusWrap.innerHTML = "";

  

    for(const h of horsesList){
      horseWrap.appendChild(makeFilterButton({
        text: prettyHorseLabel(h.label),
        value: h.key,
        active: activeHorse === h.key,
        onClick: ()=>{
          activeHorse = (activeHorse === h.key) ? "__all__" : h.key;
          updateFilterUI();
          applyFilters();
        }
      }));
    }



    for(const k of ["upcoming","underway","completed"]){
      statusWrap.appendChild(makeFilterButton({
        text: prettyStatusLabel(k),
        value: k,
        active: activeStatus === k,
        onClick: ()=>{
          activeStatus = (activeStatus === k) ? "__all__" : k;
          updateFilterUI();
          applyFilters();
        }
      }));
    }

    const horseExists = activeHorse === "__all__" || horsesList.some(x=>x.key === activeHorse);
    if(!horseExists) activeHorse = "__all__";

    updateFilterUI();
    applyFilters();
    syncFilterBarHeight();
  }

  /* ----------------------------
     RENDER + REFRESH
  -----------------------------*/

  function renderRows(rows){
    if(!Array.isArray(rows) || rows.length === 0){
      document.getElementById("rings").innerHTML = `<div class="muted">No schedule rows.</div>`;
      destroyActiveRingObserver();
      document.getElementById("horseFilters").innerHTML = "";
      document.getElementById("statusFilters").innerHTML = "";
      syncFilterBarHeight();
      return;
    }

    setHeader(rows);

    const ringEls = buildRings(rows);

    const container = document.getElementById("rings");
    container.innerHTML = "";
    for(const el of ringEls) container.appendChild(el);

    buildBottomNav(ringEls);
    syncBottomNavHeight();

    renderFilters();
    setupActiveRingObserver();
  }

  function updatePublishedFromHeader(lastMod){
    if(!lastMod) return;
    const ms = Date.parse(lastMod);
    if(Number.isFinite(ms)) publishedAtMs = ms;
  }

  async function initialLoad(){
    currentDataUrl = resolveDataUrl();

    const { txt, lastMod } = await fetchTextMeta(currentDataUrl);
    lastRaw = txt;
    lastLastMod = lastMod || null;
    updatePublishedFromHeader(lastMod);

    const rows = parseJsonText(txt, currentDataUrl);
    renderRows(rows);
  }

  async function pollForUpdates(){
    if(isRefreshing) return;
    if(!currentDataUrl) return;

    isRefreshing = true;
    try{
      const { txt, lastMod } = await fetchTextMeta(currentDataUrl);

      const lmChanged = !!(lastMod && lastLastMod && lastMod !== lastLastMod);
      const bodyChanged = (lastRaw !== null && txt !== lastRaw);

      if(!lmChanged && !bodyChanged){
        return;
      }

      lastLastMod = lastMod || lastLastMod;
      updatePublishedFromHeader(lastMod);

      const rows = parseJsonText(txt, currentDataUrl);
      const scrollY = window.scrollY;

      lastRaw = txt;
      renderRows(rows);

      window.scrollTo(0, scrollY);

    }catch(e){
      // keep existing UI
    }finally{
      isRefreshing = false;
    }
  }

  (async function main(){
    await initialLoad();

    // auto-refresh loop
    setInterval(pollForUpdates, POLL_MS);

    window.addEventListener("resize", ()=>{
      syncBottomNavHeight();
      syncFilterBarHeight();
      setupActiveRingObserver();
    });
  })().catch(err=>{
    document.getElementById("rings").innerHTML =
      `<div class="err">${esc(String(err && err.stack ? err.stack : err))}</div>`;
  });
</script>
</body>
</html>
