name: Datasets Task Runner

on:
  issues:
    types: [opened, edited, labeled]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  route:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Decide task by label
        id: decide
        uses: actions/github-script@v7
        with:
          script: |
            const labels = (context.payload.issue.labels || []).map(l => l.name);
            const has = (t) => labels.includes(t);
            if (has('task:meta-auto')) return core.setOutput('task','meta-auto');         // NEW
            if (has('task:meta-upsert')) return core.setOutput('task','meta-upsert');
            if (has('task:refresh-section')) return core.setOutput('task','refresh-section');
            core.setOutput('task','none');

      - name: Exit if not a dataset task
        if: steps.decide.outputs.task == 'none'
        run: echo "No matching task label; skipping."

      - name: Setup Node
        if: steps.decide.outputs.task != 'none'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # Only meta-auto needs cheerio
      - name: Install parser (cheerio)
        if: steps.decide.outputs.task == 'meta-auto'
        run: |
          npm init -y --silent
          npm install cheerio@1 --silent

      - name: Parse Issue Form fields
        if: steps.decide.outputs.task != 'none'
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.issue.body || '';
            const lines = body.split('\n');

            // Map visible form labels -> internal keys
            const map = {
              // ---- minimal meta-auto (6 fields) ----
              'Official website URL (required)': 'official_url',
              'Official start date (YYYY-MM-DD)': 'official_start_date',
              'Is this part of a series?': 'is_series',
              'Series week number (optional if series)': 'series_week',
              'Is this a championship?': 'is_championship',
              'Championship type (optional, e.g., pony, junior, equitation)': 'championship_type',

              // ---- existing meta-upsert labels (keep for manual path) ----
              'Slug (leave blank to auto-slugify from title)': 'slug',
              'Official show title': 'title_official',
              'Year': 'year',
              'Start date (YYYY-MM-DD)': 'start',
              'End date (YYYY-MM-DD)': 'end',
              'Timezone (IANA)': 'timezone',
              'Venue name': 'venue_name',
              'Venue street': 'addr_street',
              'Venue city': 'addr_city',
              'Venue state (2-letter)': 'addr_state',
              'Venue postal': 'addr_postal',
              'Venue country': 'addr_country',
              'Venue latitude': 'geo_lat',
              'Venue longitude': 'geo_lon',
              'Primary airports (IATA, comma-separated)': 'airports_primary',
              'Source URLs (one per line; official → venue → federation)': 'sources',
              'Notes (conflicts, aliases, co-located shows)': 'notes',

              // ---- refresh-section labels ----
              'Show slug': 'slug',
              'Section': 'section',
              'Notes (optional)': 'notes'
            };

            const fields = {};
            let currentKey = null;
            const getLabel = l => l.replace(/^###\s+/,'').trim();

            for (let i=0; i<lines.length; i++) {
              const line = lines[i];

              if (line.startsWith('### ')) {
                const label = getLabel(line);
                currentKey = map[label] || null;
                continue;
              }

              if (currentKey) {
                if (line.startsWith('### ')) { currentKey = null; continue; }
                if (line.trim() === '') { continue; }
                const prev = fields[currentKey] || '';
                fields[currentKey] = prev ? (prev + '\n' + line) : line;
              }
            }

            core.setOutput('fields', JSON.stringify(fields));

      # ---------- Optional: auto-rename the Issue using the URL hostname ----------
      - name: Rename issue title (meta-auto)
        if: steps.decide.outputs.task == 'meta-auto'
        uses: actions/github-script@v7
        with:
          script: |
            const fields = JSON.parse('${{ steps.parse.outputs.fields }}' || '{}');
            const url = (fields.official_url || '').trim();
            const host = url ? new URL(url).hostname.replace(/^www\./,'') : 'unknown';
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              title: `auto-meta: ${host}`
            });

      # ---------- NEW: meta-auto (URL required; start date optional; flags) ----------
      - name: Meta auto (scaffold events/meta.json from URL)
        if: steps.decide.outputs.task == 'meta-auto'
        run: |
          node - <<'NODE'
          const fs=require('fs'), path=require('path');
          const cheerio=require('cheerio');

          const fields = JSON.parse(process.env.FIELDS || '{}');
          const officialUrl = (fields.official_url||'').trim();
          const startIn = (fields.official_start_date||'').trim();   // may be empty
          const endIn   = (fields.official_end_date||'').trim();     // not in minimal form; safe if empty
          if(!officialUrl){ console.error('Missing official_url'); process.exit(1); }

          const today = new Date().toISOString().slice(0,10);
          const toSlug = s => s.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
          const seasonForMonth = m => (m<=0||m>12)?null: (m<=2||m===12)?'winter': (m<=5)?'spring': (m<=8)?'summer':'fall';
          const monthName = (dtStr) => dtStr ? new Date(dtStr).toLocaleString('en-US',{month:'long'}) : null;
          const num = v => v==null||v===''?null:Number(v);
          const yes = v => (v||'').toLowerCase().startsWith('y');

          async function fetchText(url){
            const res = await fetch(url, { headers:{'user-agent':'clear-round-runner/1.0 (+github-actions)'}});
            if(!res.ok) throw new Error('HTTP '+res.status+' '+url);
            return await res.text();
          }
          function pickTitle($){
            return $('meta[property="og:title"]').attr('content')
              || $('meta[name="twitter:title"]').attr('content')
              || $('h1').first().text()
              || $('title').first().text()
              || null;
          }
          function pickCanonical($, base){
            const c = $('link[rel="canonical"]').attr('href');
            try { return new URL(c||'', base).href; } catch { return base; }
          }

          (async ()=>{
            const html = await fetchText(officialUrl);
            const $ = cheerio.load(html);
            const canonical = pickCanonical($, officialUrl);
            let official_name = (pickTitle($)||'').trim() || new URL(officialUrl).hostname.replace(/^www\./,'');

            // Derivations (guard if start date missing)
            const hasStart = !!startIn;
            const yyyymm = hasStart ? startIn.slice(0,7) : null;
            const month_name = hasStart ? monthName(startIn) : null;
            const season = hasStart ? seasonForMonth(Number(startIn.slice(5,7))) : null;

            // Slug & IDs
            const slug = toSlug(official_name);
            const show_uid = slug;
            const event_uid = hasStart ? `${slug}_${yyyymm}` : null;

            // Flags from form
            const isSeries = yes(fields.is_series);
            const seriesWeek = num(fields.series_week);
            const isChamp = yes(fields.is_championship);
            const champType = (fields.championship_type||'').trim() || null;

            const metaDoc = {
              show_uid,
              display_name: official_name,
              event_uid,
              slug,
              timezone: "America/New_York",
              created_date: today,
              last_updated: today,
              meta: {
                official_link: canonical || officialUrl,
                official_name: official_name,
                official_start_date: hasStart ? startIn : null,
                official_end_date: hasStart ? (endIn || null) : null,
                venue_name: null,
                venue_address: null,
                venue_city: null,
                venue_state: null,
                venue_zip: null,
                venue_coords: {
                  lat: null, lon: null,
                  coordinate_source: null,
                  google_place_id: null,
                  maps_url: null
                },
                notes: hasStart ? "AUTO: scaffolded; verify venue and end date if needed."
                                : "AUTO: scaffolded; add start/end dates and venue when confirmed.",
                sources: [canonical, officialUrl].filter(Boolean)
              },
              derived: {
                yyyymm,
                month_name,
                season,
                status_window: hasStart ? (
                  (endIn && new Date(endIn) < new Date(today)) ? "past" :
                  (new Date(startIn) > new Date(today)) ? "upcoming" :
                  (endIn ? "current" : "unknown")
                ) : "unknown"
              },
              search: {
                auto_keys: Array.from(new Set([
                  ...official_name.toLowerCase().split(/[^a-z0-9]+/).filter(s=>s.length>2),
                  ...(hasStart ? [startIn.slice(0,4)] : [])
                ])),
                curated_keys: [],
                facets: {
                  discipline: null,
                  rating: isChamp ? "championship" : null,
                  championship_type: champType,
                  state: null,
                  region: null,
                  airports_primary: [],
                  season,
                  is_series: isSeries,
                  series_week: seriesWeek
                }
              },
              aliases: { curated: [] },
              ops: {
                needs_meta_refresh: !hasStart,         // follow-up needed if no date
                needs_research: true,
                needs_blog: false,
                last_ops_check: today,
                stale_reason: hasStart ? null : "missing_start_date"
              },
              quick_notes: [
                "Scaffolded from official link.",
                hasStart ? "Start date provided." : "Start date missing; fill when available.",
                isSeries ? `Series week ${seriesWeek ?? "unspecified"}.` : "Not marked as series.",
                isChamp ? `Championship type: ${champType || "unspecified"}.` : "Not marked as championship."
              ],
              suggested_save: {
                file_path: `/shows/${slug}/events/meta.json`,
                download_name: `meta-${slug}.json`
              },
              admin_preview: {
                root: `/shows/${slug}/`,
                paths: [
                  `/shows/${slug}/events/meta.json`
                ]
              }
            };

            // write to /shows/<slug>/events/meta.json
            const dir = path.join('shows', slug, 'events');
            fs.mkdirSync(dir,{recursive:true});
            fs.writeFileSync(path.join(dir,'meta.json'), JSON.stringify(metaDoc,null,2));

            // update index.json
            const idxPath='index.json';
            let index={version:1,generated_at:today,shows:[]};
            if(fs.existsSync(idxPath)) index=JSON.parse(fs.readFileSync(idxPath,'utf8'));
            const entry = {
              slug,
              display_name: metaDoc.display_name,
              yyyymm: metaDoc.derived.yyyymm,
              title_official: metaDoc.meta.official_name,
              location_city: metaDoc.meta.venue_city,
              location_state: metaDoc.meta.venue_state,
              venue_name: metaDoc.meta.venue_name,
              meta_path: `shows/${slug}/events/meta.json`,
              has_sections: [],
              flags: { is_series: isSeries, is_championship: isChamp }
            };
            const i=index.shows.findIndex(s=>s.slug===slug);
            if(i>=0) index.shows[i] = {...index.shows[i], ...entry};
            else index.shows.push(entry);
            index.generated_at=today;
            fs.writeFileSync(idxPath, JSON.stringify(index,null,2));
          })().catch(e=>{ console.error(e); process.exit(1); });
          NODE
        env:
          FIELDS: ${{ steps.parse.outputs.fields }}

      # ---------- existing meta-upsert (manual form path) ----------
      - name: Meta upsert (create/update meta.json + index.json)
        if: steps.decide.outputs.task == 'meta-upsert'
        run: |
          node - <<'NODE'
          const fs=require('fs'), path=require('path');
          const fields=JSON.parse(process.env.FIELDS);

          const toSlug = (s)=> s.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
          const slug = (fields.slug && fields.slug.trim()) || toSlug(fields.title_official || '');
          if(!slug) { console.error('Missing slug/title_official'); process.exit(1); }

          const dir = path.join('shows', slug);
          fs.mkdirSync(dir, {recursive:true});

          const metaPath = path.join(dir, 'meta.json');

          const meta = {
            slug,
            title_official: fields.title_official || null,
            organizer: null,
            rating: { fei: null, national: null },
            dates: {
              year: Number(fields.year),
              start: fields.start,
              end: fields.end,
              timezone: fields.timezone || 'America/New_York'
            },
            venue: {
              name: fields.venue_name || null,
              address: {
                street: fields.addr_street || null,
                city: fields.addr_city || null,
                state: fields.addr_state || null,
                postal: fields.addr_postal || null,
                country: fields.addr_country || 'USA'
              },
              geo: {
                lat: Number(fields.geo_lat),
                lon: Number(fields.geo_lon)
              }
            },
            airports_primary: (fields.airports_primary||'').split(',').map(s=>s.trim()).filter(Boolean),
            co_located: [],
            sources: (fields.sources||'').split('\n').map(s=>s.trim()).filter(Boolean),
            notes: fields.notes || null
          };

          fs.writeFileSync(metaPath, JSON.stringify(meta,null,2));

          // Update index.json
          const idxPath = 'index.json';
          let index = { version: 1, generated_at: new Date().toISOString().slice(0,10), shows: [] };
          if (fs.existsSync(idxPath)) index = JSON.parse(fs.readFileSync(idxPath,'utf8'));

          const entry = {
            slug,
            title_official: meta.title_official,
            location_city: meta.venue.address.city,
            location_state: meta.venue.address.state,
            venue_name: meta.venue.name,
            meta_path: `shows/${slug}/meta.json`,
            has_sections: []
          };

          const i = index.shows.findIndex(s => s.slug === slug);
          if (i >= 0) index.shows[i] = {...index.shows[i], ...entry};
          else index.shows.push(entry);

          fs.writeFileSync(idxPath, JSON.stringify(index,null,2));
          NODE
        env:
          FIELDS: ${{ steps.parse.outputs.fields }}

      # ---------- existing refresh-section (with index has_sections update) ----------
      - name: Refresh section (scaffold research file if needed)
        if: steps.decide.outputs.task == 'refresh-section'
        run: |
          node - <<'NODE'
          const fs=require('fs'), path=require('path');
          const fields=JSON.parse(process.env.FIELDS);

          const slug = fields.slug;
          const section = fields.section;
          if(!slug || !section) { console.error('Missing slug/section'); process.exit(1); }

          const dir = path.join('shows', slug, 'research');
          fs.mkdirSync(dir, {recursive:true});

          const file = path.join(dir, `${section}.json`);
          const today = new Date().toISOString().slice(0,10);
          let obj = {
            status: 'draft',
            last_verified_at: today,
            expires_after_days: section === 'temps' ? 1 : 180,
            items: [],
            notes: fields.notes || null,
            source_urls: []
          };

          if (fs.existsSync(file)) {
            try {
              const cur = JSON.parse(fs.readFileSync(file,'utf8'));
              obj = { ...cur, last_verified_at: today };
            } catch {}
          }

          fs.writeFileSync(file, JSON.stringify(obj,null,2));

          // Update index.json has_sections
          const idxPath = 'index.json';
          let index = { version: 1, generated_at: today, shows: [] };
          if (fs.existsSync(idxPath)) index = JSON.parse(fs.readFileSync(idxPath,'utf8'));
          const j = index.shows.findIndex(s => s.slug === slug);
          if (j >= 0) {
            const set = new Set([...(index.shows[j].has_sections || []), section]);
            index.shows[j].has_sections = Array.from(set);
          } else {
            index.shows.push({
              slug,
              title_official: null,
              location_city: null,
              location_state: null,
              venue_name: null,
              meta_path: `shows/${slug}/meta.json`,
              has_sections: [section]
            });
          }
          index.generated_at = today;
          fs.writeFileSync(idxPath, JSON.stringify(index,null,2));
          NODE
        env:
          FIELDS: ${{ steps.parse.outputs.fields }}

      - name: Open PR
        if: steps.decide.outputs.task != 'none'
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "chore: ${{ steps.decide.outputs.task }} via issue #${{ github.event.issue.number }}"
          title: "Automated: ${{ steps.decide.outputs.task }} for #${{ github.event.issue.number }}"
          body: "This PR was generated from issue #${{ github.event.issue.number }}.\n\nPlease review changes and merge if correct."
          branch: "bot/${{ steps.decide.outputs.task }}-${{ github.event.issue.number }}"
          labels: "auto-pr"

      - name: Comment with PR link
        if: steps.decide.outputs.task != 'none'
        uses: actions/github-script@v7
        with:
          script: |
            const prNum = '${{ steps.cpr.outputs.pull-request-number }}';
            const prUrl = prNum ? `${context.payload.repository.html_url}/pull/${prNum}` : null;
            const msg = prUrl ? `Opened PR: ${prUrl}` : 'No changes to commit.';
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: msg
            });
