name: Datasets Task Runner

on:
  issues:
    types: [opened, edited, labeled]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  route:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      # Robust routing: works via label OR form content
      - name: Decide task
        id: decide
        uses: actions/github-script@v7
        with:
          script: |
            const labels = (context.payload.issue.labels || []).map(l => l.name);
            const body = context.payload.issue.body || '';
            const has = (t) => labels.includes(t);

            if (has('task:meta-auto') || body.includes('### Official website URL')) {
              core.setOutput('task','meta-auto'); return;
            }
            if (has('task:meta-enrich') || body.includes('### Show slug (required)')) {
              core.setOutput('task','meta-enrich'); return;
            }
            if (has('task:meta-upsert')) {
              core.setOutput('task','meta-upsert'); return;
            }
            if (has('task:refresh-section')) {
              core.setOutput('task','refresh-section'); return;
            }
            core.setOutput('task','none');

      - name: Exit if not a dataset task
        if: steps.decide.outputs.task == 'none'
        run: echo "No matching task; skipping."

      - name: Setup Node
        if: steps.decide.outputs.task != 'none'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # Needed for meta-auto and meta-enrich (safe to skip for others)
      - name: Install parser (cheerio)
        if: steps.decide.outputs.task == 'meta-auto' || steps.decide.outputs.task == 'meta-enrich'
        run: |
          npm init -y --silent
          npm install cheerio@1 --silent

      # Parse the Issue Form fields
      - name: Parse Issue Form fields
        if: steps.decide.outputs.task != 'none'
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.issue.body || '';
            const lines = body.split('\n');

            // Map visible form labels -> internal keys
            const map = {
              // minimal meta-auto (6 fields)
              'Official website URL (required)': 'official_url',
              'Official start date (YYYY-MM-DD)': 'official_start_date',
              'Is this part of a series?': 'is_series',
              'Series week number (optional if series)': 'series_week',
              'Is this a championship?': 'is_championship',
              'Championship type (optional, e.g., pony, junior, equitation)': 'championship_type',

              // meta-enrich
              'Show slug (required)': 'show_slug',
              'Crawl depth': 'crawl_depth',

              // meta-upsert (manual path)
              'Slug (leave blank to auto-slugify from title)': 'slug',
              'Official show title': 'title_official',
              'Year': 'year',
              'Start date (YYYY-MM-DD)': 'start',
              'End date (YYYY-MM-DD)': 'end',
              'Timezone (IANA)': 'timezone',
              'Venue name': 'venue_name',
              'Venue street': 'addr_street',
              'Venue city': 'addr_city',
              'Venue state (2-letter)': 'addr_state',
              'Venue postal': 'addr_postal',
              'Venue country': 'addr_country',
              'Venue latitude': 'geo_lat',
              'Venue longitude': 'geo_lon',
              'Primary airports (IATA, comma-separated)': 'airports_primary',
              'Source URLs (one per line; official → venue → federation)': 'sources',
              'Notes (conflicts, aliases, co-located shows)': 'notes',

              // refresh-section
              'Show slug': 'slug',
              'Section': 'section',
              'Notes (optional)': 'notes'
            };

            const fields = {};
            let currentKey = null;
            const getLabel = l => l.replace(/^###\s+/,'').trim();

            for (const line of lines) {
              if (line.startsWith('### ')) {
                const label = getLabel(line);
                currentKey = map[label] || null;
                continue;
              }
              if (currentKey) {
                if (line.startsWith('### ')) { currentKey = null; continue; }
                if (!line.trim()) continue;
                fields[currentKey] = fields[currentKey] ? fields[currentKey] + '\n' + line : line;
              }
            }
            core.setOutput('fields', JSON.stringify(fields));

      - name: Debug parsed fields
        if: steps.decide.outputs.task != 'none'
        run: |
          echo 'FIELDS_JSON>>'
          echo '${{ steps.parse.outputs.fields }}'

      # Cosmetic: auto-rename Issue title from URL hostname
      - name: Rename issue title (meta-auto)
        if: steps.decide.outputs.task == 'meta-auto'
        uses: actions/github-script@v7
        with:
          script: |
            const fields = JSON.parse('${{ steps.parse.outputs.fields }}' || '{}');
            const url = (fields.official_url || '').trim();
            const host = url ? new URL(url).hostname.replace(/^www\./,'') : 'unknown';
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              title: `auto-meta: ${host}`
            });

      # ---------- meta-auto ----------
      - name: Meta auto (scaffold events/meta.json from URL)
        if: steps.decide.outputs.task == 'meta-auto'
        run: |
          node - <<'NODE'
          const fs=require('fs'), path=require('path');
          let cheerio=null; try{ cheerio=require('cheerio'); }catch{}
          const fields = JSON.parse(process.env.FIELDS || '{}');

          const officialUrl = (fields.official_url||'').trim();
          const startIn = (fields.official_start_date||'').trim();   // optional
          if(!officialUrl){ console.error('Missing official_url'); process.exit(1); }

          const today = new Date().toISOString().slice(0,10);
          const toSlug = s => s.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
          const seasonForMonth = m => (m<=0||m>12)?null: (m<=2||m===12)?'winter': (m<=5)?'spring': (m<=8)?'summer':'fall';
          const monthName = d => d ? new Date(d).toLocaleString('en-US',{month:'long'}) : null;
          const num = v => v==null||v===''?null:Number(v);
          const yes = v => (v||'').toLowerCase().startsWith('y');

          async function fetchText(url){
            const res = await fetch(url, { headers:{'user-agent':'clear-round-runner/1.0 (+github-actions)'}});
            if(!res.ok) throw new Error('HTTP '+res.status+' '+url);
            return await res.text();
          }
          async function getTitleAndCanonical(url){
            let title = new URL(url).hostname.replace(/^www\./,'');
            let canonical = url;
            if (!cheerio) return { title, canonical };
            try {
              const html = await fetchText(url);
              const $ = cheerio.load(html);
              const t = $('meta[property="og:title"]').attr('content')
                    || $('meta[name="twitter:title"]').attr('content')
                    || $('h1').first().text()
                    || $('title').first().text()
                    || null;
              const c = $('link[rel="canonical"]').attr('href');
              if (t && t.trim()) title = t.trim();
              if (c) canonical = new URL(c, url).href;
            } catch {}
            return { title, canonical };
          }

          (async ()=>{
            const { title: official_name, canonical } = await getTitleAndCanonical(officialUrl);

            const hasStart = !!startIn;
            const yyyymm = hasStart ? startIn.slice(0,7) : null;
            const month_name = hasStart ? monthName(startIn) : null;
            const season = hasStart ? seasonForMonth(Number(startIn.slice(5,7))) : null;

            const slug = toSlug(official_name);
            const show_uid = slug;
            const event_uid = hasStart ? `${slug}_${yyyymm}` : null;

            const isSeries = yes(fields.is_series);
            const seriesWeek = num(fields.series_week);
            const isChamp = yes(fields.is_championship);
            const champType = (fields.championship_type||'').trim() || null;

            const metaDoc = {
              show_uid,
              display_name: official_name,
              event_uid,
              slug,
              timezone: "America/New_York",
              created_date: today,
              last_updated: today,
              meta: {
                official_link: canonical || officialUrl,
                official_name: official_name,
                official_start_date: hasStart ? startIn : null,
                official_end_date: null,
                venue_name: null,
                venue_address: null,
                venue_city: null,
                venue_state: null,
                venue_zip: null,
                venue_coords: {
                  lat: null, lon: null,
                  coordinate_source: null,
                  google_place_id: null,
                  maps_url: null
                },
                notes: hasStart ? "AUTO: scaffolded; verify venue and end date if needed."
                                : "AUTO: scaffolded; add start/end dates and venue when confirmed.",
                sources: [canonical || officialUrl, officialUrl].filter(Boolean)
              },
              derived: {
                yyyymm,
                month_name,
                season,
                status_window: hasStart ? (new Date(startIn) > new Date(today) ? "upcoming" : "unknown") : "unknown"
              },
              search: {
                auto_keys: Array.from(new Set([
                  ...official_name.toLowerCase().split(/[^a-z0-9]+/).filter(s=>s.length>2),
                  ...(hasStart ? [startIn.slice(0,4)] : [])
                ])),
                curated_keys: [],
                facets: {
                  discipline: null,
                  rating: isChamp ? "championship" : null,
                  championship_type: champType,
                  state: null,
                  region: null,
                  airports_primary: [],
                  season,
                  is_series: isSeries,
                  series_week: seriesWeek
                }
              },
              aliases: { curated: [] },
              ops: {
                needs_meta_refresh: !hasStart,
                needs_research: true,
                needs_blog: false,
                last_ops_check: today,
                stale_reason: hasStart ? null : "missing_start_date"
              },
              quick_notes: [
                "Scaffolded from official link.",
                hasStart ? "Start date provided." : "Start date missing; fill when available.",
                isSeries ? `Series week ${seriesWeek ?? "unspecified"}.` : "Not marked as series.",
                isChamp ? `Championship type: ${champType || "unspecified"}.` : "Not marked as championship."
              ],
              suggested_save: {
                file_path: `/shows/${slug}/events/meta.json`,
                download_name: `meta-${slug}.json`
              },
              admin_preview: {
                root: `/shows/${slug}/`,
                paths: [ `/shows/${slug}/events/meta.json` ]
              }
            };

            // write meta
            const dir = path.join('shows', slug, 'events');
            fs.mkdirSync(dir,{recursive:true});
            fs.writeFileSync(path.join(dir,'meta.json'), JSON.stringify(metaDoc,null,2));

            // update index.json
            const idxPath='index.json';
            let index={version:1,generated_at:today,shows:[]};
            if(fs.existsSync(idxPath)) index=JSON.parse(fs.readFileSync(idxPath,'utf8'));
            const entry = {
              slug,
              display_name: metaDoc.display_name,
              yyyymm: metaDoc.derived.yyyymm,
              title_official: metaDoc.meta.official_name,
              location_city: metaDoc.meta.venue_city,
              location_state: metaDoc.meta.venue_state,
              venue_name: metaDoc.meta.venue_name,
              meta_path: `shows/${slug}/events/meta.json`,
              has_sections: [],
              flags: { is_series: isSeries, is_championship: isChamp }
            };
            const i=index.shows.findIndex(s=>s.slug===slug);
            if(i>=0) index.shows[i] = {...index.shows[i], ...entry};
            else index.shows.push(entry);
            index.generated_at=today;
            fs.writeFileSync(idxPath, JSON.stringify(index,null,2));

            console.log('WROTE:', `shows/${slug}/events/meta.json`);
          })().catch(e=>{ console.error(e); process.exit(1); });
          NODE
        env:
          FIELDS: ${{ steps.parse.outputs.fields }}

      # ---------- meta-enrich ----------
      - name: Meta enrich (from existing events/meta.json)
        if: steps.decide.outputs.task == 'meta-enrich'
        run: |
          node - <<'NODE'
          const fs=require('fs'), path=require('path');
          const cheerio=require('cheerio');

          const fields = JSON.parse(process.env.FIELDS || '{}');
          const slug = (fields.show_slug||'').trim();
          if(!slug){ console.error('Missing show_slug'); process.exit(1); }

          const metaPath = path.join('shows', slug, 'events', 'meta.json');
          if(!fs.existsSync(metaPath)){ console.error('No meta.json at '+metaPath); process.exit(1); }

          const today = new Date().toISOString().slice(0,10);
          const seasonForMonth = (m) => (m<=2||m===12)?'winter':(m<=5)?'spring':(m<=8)?'summer':'fall';
          const monthName = (d) => d ? new Date(d).toLocaleString('en-US',{month:'long'}) : null;
          const pad = n => String(n).padStart(2,'0');

          async function fetchText(url){
            const res = await fetch(url, { headers:{'user-agent':'clear-round-runner/1.0 (+github-actions)'}});
            if(!res.ok) throw new Error('HTTP '+res.status+' '+url);
            return await res.text();
          }
          function parseJSONLD($){
            const out = { addr:null, venueName:null, end:null, start:null, geo:null };
            $('script[type="application/ld+json"]').each((_,el)=>{
              let txt = $(el).contents().text();
              try {
                const json = JSON.parse(txt);
                const arr = Array.isArray(json) ? json : [json];
                for (const o of arr){
                  if (o['@type'] && String(o['@type']).toLowerCase().includes('event')) {
                    out.start = out.start || o.startDate || null;
                    out.end   = out.end   || o.endDate   || null;
                    if (o.location){
                      const loc=o.location;
                      if (loc.address) out.addr = out.addr || loc.address;
                      if (loc.name) out.venueName = out.venueName || loc.name;
                      if (loc.geo && (loc.geo.latitude || loc.geo.longitude)) {
                        out.geo = out.geo || { lat: Number(loc.geo.latitude), lon: Number(loc.geo.longitude) };
                      }
                    }
                  }
                  if (o.address && !out.addr) out.addr = o.address;
                  if (o.name && !out.venueName) out.venueName = o.name;
                  if (o.geo && (o.geo.latitude || o.geo.longitude) && !out.geo) {
                    out.geo = { lat: Number(o.geo.latitude), lon: Number(o.geo.longitude) };
                  }
                }
              } catch {}
            });
            if (out.addr && typeof out.addr === 'object'){
              out.addr = {
                street: out.addr.streetAddress || null,
                city: out.addr.addressLocality || null,
                state: out.addr.addressRegion  || null,
                postal: out.addr.postalCode    || null,
                country: out.addr.addressCountry || null
              };
            } else out.addr = null;
            return out;
          }
          function regexAddressFallback($){
            const text = $('body').text().replace(/\s+/g,' ');
            const m = text.match(/([0-9]{1,5}\s+[A-Za-z0-9\.\s]+),?\s+([A-Z][a-zA-Z]+),\s*([A-Z]{2})\s*(\d{5})?/);
            if(!m) return null;
            return { street: m[1], city: m[2], state: m[3], postal: m[4]||null, country: 'USA' };
          }
          function detectDates($, prevStart){
            const blob = $.text().replace(/\s+/g,' ');
            let start=null, end=null;
            const iso = blob.match(/(20\d{2}-\d{2}-\d{2})\s*(?:to|-|–|—|through)\s*(20\d{2}-\d{2}-\d{2})/i);
            if (iso){ start=iso[1]; end=iso[2]; }
            if(!start){
              const m = blob.match(/(January|February|March|April|May|June|July|August|September|October|November|December|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sept|Sep|Oct|Nov|Dec)\s+(\d{1,2})(?:\s*[–—-]\s*(January|February|March|April|May|June|July|August|September|October|November|December|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sept|Sep|Oct|Nov|Dec)\s+(\d{1,2}))?,?\s*(20\d{2})/i);
              if(m){
                const months={January:1,February:2,March:3,April:4,May:5,June:6,July:7,August:8,September:9,Sept:9,October:10,November:11,December:12,Jan:1,Feb:2,Mar:3,Apr:4,May:5,Jun:6,Jul:7,Aug:8,Sep:9,Oct:10,Nov:11,Dec:12};
                const mo1=months[m[1]], d1=m[2], y=m[5], mo2=m[3]?months[m[3]]:mo1, d2=m[4]||d1;
                const p=n=>String(n).padStart(2,'0');
                start=`${y}-${p(mo1)}-${p(d1)}`; end=`${y}-${p(mo2)}-${p(d2)}`;
              }
            }
            if (!start && prevStart) start=prevStart;
            return {start,end};
          }

          (async ()=>{
            const metaDoc = JSON.parse(fs.readFileSync(metaPath,'utf8'));
            const baseUrl = metaDoc?.meta?.official_link;
            if(!baseUrl){ console.error('meta.meta.official_link missing'); process.exit(1); }

            const html = await fetchText(baseUrl);
            const $ = cheerio.load(html);

            const titleRaw = $('meta[property="og:title"]').attr('content')
              || $('meta[name="twitter:title"]').attr('content')
              || $('h1').first().text()
              || $('title').first().text()
              || metaDoc.display_name
              || new URL(baseUrl).hostname.replace(/^www\./,'');
            const title = titleRaw.replace(/\s+/g,' ').trim();

            const canonical = $('link[rel="canonical"]').attr('href');
            const officialLink = canonical ? new URL(canonical, baseUrl).href : baseUrl;

            const ld = parseJSONLD($);
            const addr = ld.addr || regexAddressFallback($) || {
              street: metaDoc.meta.venue_address || null,
              city: metaDoc.meta.venue_city || null,
              state: metaDoc.meta.venue_state || null,
              postal: metaDoc.meta.venue_zip || null,
              country: 'USA'
            };

            const det = detectDates($, metaDoc.meta.official_start_date || null);
            const start = det.start || metaDoc.meta.official_start_date || null;
            const end   = det.end   || metaDoc.meta.official_end_date   || null;

            metaDoc.display_name = title;
            metaDoc.last_updated = today;
            metaDoc.meta.official_link = officialLink;
            metaDoc.meta.official_name = title;
            metaDoc.meta.official_start_date = start;
            metaDoc.meta.official_end_date = end;
            metaDoc.meta.venue_name = ld.venueName || metaDoc.meta.venue_name || null;
            metaDoc.meta.venue_address = addr?.street || null;
            metaDoc.meta.venue_city = addr?.city || null;
            metaDoc.meta.venue_state = addr?.state || null;
            metaDoc.meta.venue_zip = addr?.postal || null;
            metaDoc.meta.venue_coords = {
              lat: (ld.geo && ld.geo.lat != null) ? Number(ld.geo.lat) : metaDoc.meta.venue_coords?.lat || null,
              lon: (ld.geo && ld.geo.lon != null) ? Number(ld.geo.lon) : metaDoc.meta.venue_coords?.lon || null,
              coordinate_source: (ld.geo && (ld.geo.lat || ld.geo.lon)) ? 'jsonld' : metaDoc.meta.venue_coords?.coordinate_source || null,
              google_place_id: metaDoc.meta.venue_coords?.google_place_id || null,
              maps_url: metaDoc.meta.venue_coords?.maps_url || null
            };

            const yyyymm = start ? start.slice(0,7) : metaDoc.derived?.yyyymm || null;
            metaDoc.derived = {
              yyyymm,
              month_name: start ? monthName(start) : (metaDoc.derived?.month_name || null),
              season: start ? seasonForMonth(Number(start.slice(5,7))) : (metaDoc.derived?.season || null),
              status_window: (end && new Date(end) < new Date(today)) ? 'past'
                              : (start && new Date(start) > new Date(today)) ? 'upcoming'
                              : (start && end) ? 'current' : 'unknown'
            };

            fs.writeFileSync(metaPath, JSON.stringify(metaDoc,null,2));

            const idxPath='index.json';
            let index={version:1,generated_at:today,shows:[]};
            if(fs.existsSync(idxPath)) index=JSON.parse(fs.readFileSync(idxPath,'utf8'));
            const entry = {
              slug,
              display_name: metaDoc.display_name,
              yyyymm: metaDoc.derived.yyyymm,
              title_official: metaDoc.meta.official_name,
              location_city: metaDoc.meta.venue_city,
              location_state: metaDoc.meta.venue_state,
              venue_name: metaDoc.meta.venue_name,
              meta_path: `shows/${slug}/events/meta.json`,
              has_sections: (index.shows.find(s=>s.slug===slug)?.has_sections)||[],
              flags: (index.shows.find(s=>s.slug===slug)?.flags)||{}
            };
            const i=index.shows.findIndex(s=>s.slug===slug);
            if(i>=0) index.shows[i] = {...index.shows[i], ...entry};
            else index.shows.push(entry);
            index.generated_at=today;
            fs.writeFileSync(idxPath, JSON.stringify(index,null,2));

            console.log('ENRICHED:', metaPath);
          })().catch(e=>{ console.error(e); process.exit(1); });
          NODE
        env:
          FIELDS: ${{ steps.parse.outputs.fields }}

      # ---------- meta-upsert (legacy/manual) ----------
      - name: Meta upsert (create/update meta.json + index.json)
        if: steps.decide.outputs.task == 'meta-upsert'
        run: |
          node - <<'NODE'
          const fs=require('fs'), path=require('path');
          const fields=JSON.parse(process.env.FIELDS || '{}');

          const toSlug = s=>s.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
          const slug = (fields.slug && fields.slug.trim()) || toSlug(fields.title_official || '');
          if(!slug){ console.error('Missing slug/title_official'); process.exit(1); }

          const dir = path.join('shows', slug);
          fs.mkdirSync(dir,{recursive:true});

          const metaPath = path.join(dir,'meta.json');

          const meta = {
            slug,
            title_official: fields.title_official || null,
            organizer: null,
            rating: { fei: null, national: null },
            dates: {
              year: Number(fields.year),
              start: fields.start,
              end: fields.end,
              timezone: fields.timezone || 'America/New_York'
            },
            venue: {
              name: fields.venue_name || null,
              address: {
                street: fields.addr_street || null,
                city: fields.addr_city || null,
                state: fields.addr_state || null,
                postal: fields.addr_postal || null,
                country: fields.addr_country || 'USA'
              },
              geo: {
                lat: Number(fields.geo_lat),
                lon: Number(fields.geo_lon)
              }
            },
            airports_primary: (fields.airports_primary||'').split(',').map(s=>s.trim()).filter(Boolean),
            co_located: [],
            sources: (fields.sources||'').split('\n').map(s=>s.trim()).filter(Boolean),
            notes: fields.notes || null
          };

          fs.writeFileSync(metaPath, JSON.stringify(meta,null,2));

          const idxPath='index.json';
          let index={version:1,generated_at:new Date().toISOString().slice(0,10),shows:[]};
          if(fs.existsSync(idxPath)) index=JSON.parse(fs.readFileSync(idxPath,'utf8'));
          const entry = {
            slug,
            title_official: meta.title_official,
            location_city: meta.venue.address.city,
            location_state: meta.venue.address.state,
            venue_name: meta.venue.name,
            meta_path: `shows/${slug}/meta.json`,
            has_sections: []
          };
          const i=index.shows.findIndex(s=>s.slug===slug);
          if(i>=0) index.shows[i] = {...index.shows[i], ...entry};
          else index.shows.push(entry);
          fs.writeFileSync(idxPath, JSON.stringify(index,null,2));
          NODE
        env:
          FIELDS: ${{ steps.parse.outputs.fields }}

      # ---------- refresh-section ----------
      - name: Refresh section (scaffold research file if needed)
        if: steps.decide.outputs.task == 'refresh-section'
        run: |
          node - <<'NODE'
          const fs=require('fs'), path=require('path');
          const fields=JSON.parse(process.env.FIELDS || '{}');

          const slug = fields.slug;
          const section = fields.section;
          if(!slug || !section) { console.error('Missing slug/section'); process.exit(1); }

          const dir = path.join('shows', slug, 'research');
          fs.mkdirSync(dir, {recursive:true});

          const file = path.join(dir, `${section}.json`);
          const today = new Date().toISOString().slice(0,10);
          let obj = {
            status: 'draft',
            last_verified_at: today,
            expires_after_days: section === 'temps' ? 1 : 180,
            items: [],
            notes: fields.notes || null,
            source_urls: []
          };

          if (fs.existsSync(file)) {
            try {
              const cur = JSON.parse(fs.readFileSync(file,'utf8'));
              obj = { ...cur, last_verified_at: today };
            } catch {}
          }

          fs.writeFileSync(file, JSON.stringify(obj,null,2));

          // Update index.json has_sections
          const idxPath = 'index.json';
          let index = { version: 1, generated_at: today, shows: [] };
          if (fs.existsSync(idxPath)) index = JSON.parse(fs.readFileSync(idxPath,'utf8'));
          const j = index.shows.findIndex(s => s.slug === slug);
          if (j >= 0) {
            const set = new Set([...(index.shows[j].has_sections || []), section]);
            index.shows[j].has_sections = Array.from(set);
          } else {
            index.shows.push({
              slug,
              title_official: null,
              location_city: null,
              location_state: null,
              venue_name: null,
              meta_path: `shows/${slug}/meta.json`,
              has_sections: [section]
            });
          }
          index.generated_at = today;
          fs.writeFileSync(idxPath, JSON.stringify(index,null,2));
          NODE
        env:
          FIELDS: ${{ steps.parse.outputs.fields }}

      - name: Show repo changes
        if: steps.decide.outputs.task != 'none'
        run: |
          git status --porcelain
          git diff --name-only

      - name: Open PR
        if: steps.decide.outputs.task != 'none'
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.BOT_TOKEN || github.token }}
          commit-message: "chore: ${{ steps.decide.outputs.task }} via issue #${{ github.event.issue.number }}"
          title: "Automated: ${{ steps.decide.outputs.task }} for #${{ github.event.issue.number }}"
          body: "This PR was generated from issue #${{ github.event.issue.number }}."
          branch: "bot/${{ steps.decide.outputs.task }}-${{ github.event.issue.number }}"
          labels: "auto-pr"

      - name: Comment with PR link
        if: steps.decide.outputs.task != 'none'
        uses: actions/github-script@v7
        with:
          script: |
            const prNum = '${{ steps.cpr.outputs.pull-request-number }}';
            const prUrl = prNum ? `${context.payload.repository.html_url}/pull/${prNum}` : null;
            const msg = prUrl ? `Opened PR: ${prUrl}` : 'No changes to commit.';
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: msg
            });
