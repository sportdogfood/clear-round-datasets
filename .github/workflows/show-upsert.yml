name: Upsert Show

on:
  workflow_dispatch:
    inputs:
      official_url:
        description: "Official website URL (required)"
        required: true
        type: string
      official_start_date:
        description: "Start date (YYYY-MM-DD, optional)"
        required: false
        type: string
      is_series:
        description: "Part of a series?"
        required: false
        default: "No"
        type: choice
        options: ["No","Yes"]
      series_week:
        description: "Series week number (optional)"
        required: false
        type: string
      is_championship:
        description: "Championship?"
        required: false
        default: "No"
        type: choice
        options: ["No","Yes"]
      championship_type:
        description: "Championship type (e.g., pony/junior/equitation)"
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write

jobs:
  upsert:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: '20' }

      - name: Install parser
        run: |
          npm init -y --silent
          npm install cheerio@1 --silent

      - name: Upsert + Enrich meta.json and index.json
        run: |
          node - <<'NODE'
          const fs=require('fs'), path=require('path');
          const cheerio=require('cheerio');

          // ---- inputs ----
          const url = (process.env.OFFICIAL_URL||'').trim();
          const start = (process.env.OFFICIAL_START_DATE||'').trim();
          const isSeries = (process.env.IS_SERIES||'No').toLowerCase().startsWith('y');
          const seriesWeek = process.env.SERIES_WEEK ? Number(process.env.SERIES_WEEK) : null;
          const isChamp = (process.env.IS_CHAMPIONSHIP||'No').toLowerCase().startsWith('y');
          const champType = (process.env.CHAMPIONSHIP_TYPE||'').trim() || null;
          if (!url) { console.error('Missing official_url'); process.exit(1); }

          // ---- utils ----
          const today = new Date().toISOString().slice(0,10);
          const toSlug = s => s.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
          const seasonForMonth = m => (m<=0||m>12)?null: (m<=2||m===12)?'winter': (m<=5)?'spring': (m<=8)?'summer':'fall';
          const monthName = d => d ? new Date(d).toLocaleString('en-US',{month:'long'}) : null;
          const p = n => String(n).padStart(2,'0');

          async function fetchText(u){
            const res = await fetch(u, { headers:{'user-agent':'clear-round-runner/1.0 (+github-actions)'}});
            if(!res.ok) throw new Error('HTTP '+res.status+' '+u);
            return await res.text();
          }

          function parseJSONLD($){
            const out = { addr:null, venueName:null, end:null, start:null, geo:null };
            $('script[type="application/ld+json"]').each((_,el)=>{
              const raw = $(el).contents().text();
              try {
                const data = JSON.parse(raw);
                const arr = Array.isArray(data) ? data : [data];
                for (const o of arr){
                  const t = (o['@type']||'').toString().toLowerCase();
                  if (t.includes('event')) {
                    out.start = out.start || o.startDate || null;
                    out.end   = out.end   || o.endDate   || null;
                    if (o.location){
                      const loc=o.location;
                      if (loc.address) out.addr = out.addr || loc.address;
                      if (loc.name) out.venueName = out.venueName || loc.name;
                      if (loc.geo && (loc.geo.latitude || loc.geo.longitude)) {
                        out.geo = out.geo || { lat: Number(loc.geo.latitude), lon: Number(loc.geo.longitude) };
                      }
                    }
                  }
                  if (o.address && !out.addr) out.addr = o.address;
                  if (o.name && !out.venueName) out.venueName = o.name;
                  if (o.geo && (o.geo.latitude || o.geo.longitude) && !out.geo) {
                    out.geo = { lat: Number(o.geo.latitude), lon: Number(o.geo.longitude) };
                  }
                }
              } catch {}
            });
            if (out.addr && typeof out.addr === 'object'){
              out.addr = {
                street: out.addr.streetAddress || null,
                city: out.addr.addressLocality || null,
                state: out.addr.addressRegion  || null,
                postal: out.addr.postalCode    || null,
                country: out.addr.addressCountry || null
              };
            } else out.addr = null;
            return out;
          }

          function detectDates($, prevStart){
            const blob = $.text().replace(/\s+/g,' ');
            let start=null, end=null;
            const iso = blob.match(/(20\d{2}-\d{2}-\d{2})\s*(?:to|-|–|—|through)\s*(20\d{2}-\d{2}-\d{2})/i);
            if (iso){ start=iso[1]; end=iso[2]; }
            if(!start){
              const m = blob.match(/(January|February|March|April|May|June|July|August|September|October|November|December|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sept|Sep|Oct|Nov|Dec)\s+(\d{1,2})(?:\s*[–—-]\s*(January|February|March|April|May|June|July|August|September|October|November|December|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sept|Sep|Oct|Nov|Dec)\s+(\d{1,2}))?,?\s*(20\d{2})/i);
              if(m){
                const months={January:1,February:2,March:3,April:4,May:5,June:6,July:7,August:8,September:9,Sept:9,October:10,November:11,December:12,Jan:1,Feb:2,Mar:3,Apr:4,May:5,Jun:6,Jul:7,Aug:8,Sep:9,Oct:10,Nov:11,Dec:12};
                const mo1=months[m[1]], d1=m[2], y=m[5], mo2=m[3]?months[m[3]]:mo1, d2=m[4]||d1;
                start=`${y}-${p(mo1)}-${p(d1)}`; end=`${y}-${p(mo2)}-${p(d2)}`;
              }
            }
            if (!start && prevStart) start=prevStart;
            return {start,end};
          }

          async function titleAndCanonical(u){
            let title = new URL(u).hostname.replace(/^www\./,'');
            let canonical = u;
            try {
              const html = await fetchText(u);
              const $ = cheerio.load(html);
              const t = $('meta[property="og:title"]').attr('content')
                    || $('meta[name="twitter:title"]').attr('content')
                    || $('h1').first().text()
                    || $('title').first().text()
                    || null;
              const c = $('link[rel="canonical"]').attr('href');
              if (t && t.trim()) title = t.trim().replace(/\s+/g,' ');
              if (c) canonical = new URL(c, u).href;
              return { $, title, canonical };
            } catch {
              return { $:null, title, canonical };
            }
          }

          // ---- read or create meta ----
          (async ()=>{
            const { $, title, canonical } = await titleAndCanonical(url);
            const official_name = title;
            const hasStart = !!start;
            const yyyymm = hasStart ? start.slice(0,7) : null;
            const month_name = hasStart ? monthName(start) : null;
            const season = hasStart ? seasonForMonth(Number(start.slice(5,7))) : null;

            const slug = toSlug(official_name);
            const dir = path.join('shows', slug, 'events');
            const metaPath = path.join(dir, 'meta.json');
            fs.mkdirSync(dir, {recursive:true});

            let metaDoc = fs.existsSync(metaPath)
              ? JSON.parse(fs.readFileSync(metaPath,'utf8'))
              : {
                  show_uid: slug,
                  display_name: official_name,
                  event_uid: hasStart ? `${slug}_${yyyymm}` : null,
                  slug,
                  timezone: "America/New_York",
                  created_date: today,
                  last_updated: today,
                  meta: {
                    official_link: canonical || url,
                    official_name: official_name,
                    official_start_date: hasStart ? start : null,
                    official_end_date: null,
                    venue_name: null,
                    venue_address: null,
                    venue_city: null,
                    venue_state: null,
                    venue_zip: null,
                    venue_coords: {
                      lat: null, lon: null,
                      coordinate_source: null,
                      google_place_id: null,
                      maps_url: null
                    },
                    notes: hasStart ? "AUTO: scaffolded; verify venue and end date if needed."
                                    : "AUTO: scaffolded; add start/end dates and venue when confirmed.",
                    sources: [canonical || url, url].filter(Boolean)
                  },
                  derived: {
                    yyyymm,
                    month_name,
                    season,
                    status_window: hasStart ? (new Date(start) > new Date(today) ? "upcoming" : "unknown") : "unknown"
                  },
                  search: {
                    auto_keys: Array.from(new Set([
                      ...official_name.toLowerCase().split(/[^a-z0-9]+/).filter(s=>s.length>2),
                      ...(hasStart ? [start.slice(0,4)] : [])
                    ])),
                    curated_keys: [],
                    facets: {
                      discipline: null,
                      rating: isChamp ? "championship" : null,
                      championship_type: champType,
                      state: null,
                      region: null,
                      airports_primary: [],
                      season,
                      is_series: isSeries,
                      series_week: seriesWeek
                    }
                  },
                  aliases: { curated: [] },
                  ops: {
                    needs_meta_refresh: !hasStart,
                    needs_research: true,
                    needs_blog: false,
                    last_ops_check: today,
                    stale_reason: hasStart ? null : "missing_start_date"
                  },
                  quick_notes: [],
                  suggested_save: {
                    file_path: `/shows/${slug}/events/meta.json`,
                    download_name: `meta-${slug}.json`
                  },
                  admin_preview: { root: `/shows/${slug}/`, paths: [ `/shows/${slug}/events/meta.json` ] }
                };

            // ---- enrich (if we could fetch HTML) ----
            if ($) {
              // prefer JSON-LD for address/dates/geo
              const ld = parseJSONLD($);
              const det = detectDates($, metaDoc.meta.official_start_date || null);
              const startE = det.start || metaDoc.meta.official_start_date || null;
              const endE   = det.end   || metaDoc.meta.official_end_date   || null;

              const addr = ld.addr || {
                street: metaDoc.meta.venue_address || null,
                city: metaDoc.meta.venue_city || null,
                state: metaDoc.meta.venue_state || null,
                postal: metaDoc.meta.venue_zip || null,
                country: 'USA'
              };

              metaDoc.display_name = official_name;
              metaDoc.last_updated = today;
              metaDoc.meta.official_link = canonical || url;
              metaDoc.meta.official_name = official_name;
              metaDoc.meta.official_start_date = startE;
              metaDoc.meta.official_end_date = endE;
              metaDoc.meta.venue_name = ld.venueName || metaDoc.meta.venue_name || null;
              metaDoc.meta.venue_address = addr?.street || null;
              metaDoc.meta.venue_city = addr?.city || null;
              metaDoc.meta.venue_state = addr?.state || null;
              metaDoc.meta.venue_zip = addr?.postal || null;
              metaDoc.meta.venue_coords = {
                lat: (ld.geo && ld.geo.lat != null) ? Number(ld.geo.lat) : metaDoc.meta.venue_coords?.lat || null,
                lon: (ld.geo && ld.geo.lon != null) ? Number(ld.geo.lon) : metaDoc.meta.venue_coords?.lon || null,
                coordinate_source: (ld.geo && (ld.geo.lat || ld.geo.lon)) ? 'jsonld' : metaDoc.meta.venue_coords?.coordinate_source || null,
                google_place_id: metaDoc.meta.venue_coords?.google_place_id || null,
                maps_url: metaDoc.meta.venue_coords?.maps_url || null
              };

              const startEff = metaDoc.meta.official_start_date;
              const endEff   = metaDoc.meta.official_end_date;
              const yyyymm2 = startEff ? startEff.slice(0,7) : metaDoc.derived?.yyyymm || null;

              metaDoc.derived = {
                yyyymm: yyyymm2,
                month_name: startEff ? monthName(startEff) : (metaDoc.derived?.month_name || null),
                season: startEff ? seasonForMonth(Number(startEff.slice(5,7))) : (metaDoc.derived?.season || null),
                status_window: (endEff && new Date(endEff) < new Date(today)) ? 'past'
                                : (startEff && new Date(startEff) > new Date(today)) ? 'upcoming'
                                : (startEff && endEff) ? 'current' : 'unknown'
              };
            }

            // ---- write files ----
            fs.writeFileSync(metaPath, JSON.stringify(metaDoc,null,2));

            const idxPath='index.json';
            let index={version:1,generated_at:today,shows:[]};
            if(fs.existsSync(idxPath)) index=JSON.parse(fs.readFileSync(idxPath,'utf8'));
            const entry = {
              slug: metaDoc.slug,
              display_name: metaDoc.display_name,
              yyyymm: metaDoc.derived.yyyymm,
              title_official: metaDoc.meta.official_name,
              location_city: metaDoc.meta.venue_city,
              location_state: metaDoc.meta.venue_state,
              venue_name: metaDoc.meta.venue_name,
              meta_path: `shows/${metaDoc.slug}/events/meta.json`,
              has_sections: (index.shows.find(s=>s.slug===metaDoc.slug)?.has_sections)||[],
              flags: {
                is_series: isSeries,
                is_championship: isChamp
              }
            };
            const i=index.shows.findIndex(s=>s.slug===metaDoc.slug);
            if(i>=0) index.shows[i] = {...index.shows[i], ...entry};
            else index.shows.push(entry);
            index.generated_at=today;
            fs.writeFileSync(idxPath, JSON.stringify(index,null,2));

            console.log('UPSERTED & ENRICHED:', metaPath);
          })().catch(e=>{ console.error(e); process.exit(1); });
          NODE
        env:
          OFFICIAL_URL: ${{ inputs.official_url }}
          OFFICIAL_START_DATE: ${{ inputs.official_start_date }}
          IS_SERIES: ${{ inputs.is_series }}
          SERIES_WEEK: ${{ inputs.series_week }}
          IS_CHAMPIONSHIP: ${{ inputs.is_championship }}
          CHAMPIONSHIP_TYPE: ${{ inputs.championship_type }}

      - name: Open PR
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.BOT_TOKEN || github.token }}
          commit-message: "chore: upsert show for ${{ inputs.official_url }}"
          title: "Automated: upsert show for ${{ inputs.official_url }}"
          body: "One-button upsert+enrich."
          branch: "bot/show-upsert-${{ github.run_id }}"
          labels: "auto-pr"
