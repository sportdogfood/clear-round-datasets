# File: items/blog/cp-2/instructions.txt
# Runner: blog-cp:2 — FULL (toaster spec, no brains)
# Version: v2025-12-18-full-01
# Updated: 2025-12-18T00:00:00-05:00

============================================================
A) DEFINITIONS (CANONICAL)
============================================================

1) Street / House identity
- street_token = "blog"
- house_token  = "cp:2"   (semantic)
- house_slug   = "cp-2"   (filesystem: replace ':' -> '-')

2) Execution model (NO BRAINS)
- The runner executes job_definition.run_order directly.
- There is no delegation endpoint.
- There is no hidden orchestration.
- All coordination is via explicit bins inside one run.

3) Bins (ephemeral map)
- bins is a per-run in-memory map: bins[bin_name] = JSON object
- bins are not persisted between runs
- overwrite is forbidden (one write per bin)

4) Global rules injection (HARD)
- job_definition.global_rules MUST be injected into EVERY lane execution.
- Injection method:
  system_prompt = JSON(job_definition.global_rules) + "\n\n" + member_template_text
  user_message  = JSON(lane_input_object)
- The user_message MUST be exactly one JSON object (the lane input).
- No additional wrappers inside the user_message unless the lane template requires it.

============================================================
B) REQUIRED HOUSE FILES
============================================================

House root:
- items/blog/cp-2/

Required:
- pipeline-spec.json
- expeditor-contract.json
- final-schema.json
- commit-spec.json

Member templates required if referenced by pipeline-spec.json.templates:
- member-template-cr-prompt.txt
- member-template-cw-prompt.txt
- member-template-crwtr-prompt.txt
- member-template-pr-prompt.txt
- member-template-pw-prompt.txt
- member-template-prwtr-prompt.txt
- member-template-stchr-prompt.txt
- member-template-srwrtr-prompt.txt

Hard stop if:
- any required file is missing
- any referenced template file is missing

============================================================
C) JOB-DEFINITION (ROWS) — HARD VALIDATION
============================================================

Rows lookup:
GET /spreadsheets/GqOwXTcrQ9u14dbdcTxWa/tables/a2300cab-6557-4c6a-8e48-129b169bcc68/values/A2:B999

Select:
- Col A == "blog-cp:2"
- Col B parse JSON -> job_definition

Required fields (hard stop if missing / wrong type):
- job_id (string)
- street (string) == "blog"
- house  (string) == "cp:2"
- output_format (string)
- run_order (array of strings, non-empty)
- global_rules (object)
- datasets (array, non-empty)
- paths (object) with:
  - docs_finals_root (string, starts "docs/", ends "/")
  - docs_logs_root   (string, starts "docs/", ends "/")

Optional:
- mode (string) default "live"
- shape (string) allowed, runner does not interpret beyond logging

Hard stop if:
- run_order contains duplicates (same lane key repeated)
- any run_order lane key is not present in pipeline-spec.json lane_registry

============================================================
D) DATASETS (ROWS) — FETCH + STORE
============================================================

For each datasets[i]:
Required keys:
- role_key (string)
- domains (array of strings)
- sheet_id (string)
- table_id (string)
- range (string)

Fetch:
GET /spreadsheets/{sheet_id}/tables/{table_id}/values/{range}

Store:
datasets_by_role[role_key] = {
  "role_key": role_key,
  "domains": datasets[i].domains,
  "items": <rows from Rows>
}

Hard stop if:
- any dataset fetch fails
- role_key repeats

============================================================
E) THE TOASTER RUN-LOOP (EXECUTE run_order)
============================================================

Initialize:
- bins = {}
- lane_logs = {}

Load pipeline_spec from pipeline-spec.json.

For each lane_key in job_definition.run_order:

1) Resolve lane_spec
- lane_spec = pipeline_spec.lane_registry[lane_key]
Hard stop if missing.

2) Enforce reads_bin (when applicable)
- If lane_spec has reads_bin:
  - hard stop if bins[reads_bin] missing

3) Execute by type

--------------------------------------------
E1) exp (data_sorter)
--------------------------------------------

Lane key: "exp"
lane_spec.type must be "data_sorter"

Input object passed to exp step:
{
  "job_definition": <job_definition>,
  "datasets_by_role": <datasets_by_role>
}

Execution rule:
- exp MUST behave deterministically under expeditor-contract.json
- exp MUST normalize null/empty string fields as declared
- exp MUST NOT produce prose, summaries, or inference
- exp MUST write ONLY numbered input bins required by run_order:
  - c_in_{n} for each CR pass referenced (cr1/cr2/...)
  - p_in_{n} for each PR pass referenced (pr1/pr2/...)
- exp MUST NOT write any downstream bins (research/writer/out)

Write rule:
- exp output must be a JSON object where each key is a bin name:
  - e.g. { "c_in_1": {...}, "p_in_1": {...} }
- For each produced bin:
  - bins[bin_name] = bin_object
  - hard stop if bin_name already exists

Hard stop if:
- any required input bin (for later lanes) is missing after exp completes

Logging:
lane_logs["exp"] = {
  "writes": ["<each produced bin name>"],
  "dataset_roles_seen": ["<role_keys>"]
}

--------------------------------------------
E2) researcher / writer / rewriter / stitcher
--------------------------------------------

For lane_spec.type in {"researcher","writer","rewriter","stitcher"}:

Template resolution:
- template_file = pipeline_spec.templates[lane_spec.template_ref]
- hard stop if template_file missing

Prompt construction (HARD):
- system_prompt = JSON(job_definition.global_rules) + "\n\n" + template_text
- user_payload  = bins[reads_bin] (exactly one JSON object)

Model call:
- Must return one JSON object as plain text
- Parse JSON
- Hard stop if parse fails

Write:
- bins[writes_bin] = parsed_object
- hard stop if writes_bin already exists

Minimal validation:
- parsed_object must be an object
- if parsed_object includes job_id/street/house/lane keys, they must match job_definition + lane_key intent
- no tool calls inside the lane (members_cannot_call_tools)

Logging:
lane_logs[lane_key] = {
  "reads": reads_bin,
  "writes": writes_bin
}

--------------------------------------------
E3) commit
--------------------------------------------

Lane key: "commit"
lane_spec.type must be "commit"

Preconditions:
- bins["final_out"] must exist
- final_out must validate against final-schema.json (hard stop if mismatch)

Commit behavior (HARD):
- Follow commit-spec.json exactly
- Final JSON is committed with mutation: none
- HTML rendered deterministically only if output_format requires
- Run log committed to docs_logs_root

Hard stop if commit fails.

============================================================
F) FINAL-SCHEMA VALIDATION (HARD)
============================================================

Before commit:
- Validate bins["final_out"] against final-schema.json
Hard stop on any mismatch.

============================================================
G) SINGLE USER RESPONSE (HARD)
============================================================

On success: send exactly one message containing:
- job_id
- mode
- executed run_order
- JSON path
- HTML path (if generated)
- LOG path
- commit SHA (if available)

On failure: send exactly one message containing:
- a concise error
- phase name only:
  - job_definition
  - house load
  - dataset fetch
  - lane execution
  - final validation
  - commit

No partial progress chatter.

============================================================
END OF FILE
============================================================
