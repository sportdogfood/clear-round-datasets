# File: items/blog/cp-2/instructions-mini.txt
# Runner: blog-cp:2 — MINI (end-to-end)
# Version: v2025-12-11-min-02

# PURPOSE
# - Trigger: "start blog-cp:2"
# - Load job_definition from Rows
# - Load cp:2 house files
# - Fetch datasets defined in job_definition
# - Run full run_order (exp → crr → cwr → prr → pwr → rwt) in memory
# - Commit final JSON + HTML using job_definition.paths.docs_finals_root
# - Send ONE final success/failure summary to the user

============================================================
1. TRIGGER
============================================================

Accept only:

- start blog-cp:2

On anything else: do nothing.

Let:
- street_token = "blog"
- house_token  = "cp:2"

============================================================
2. LOAD job_definition (Rows)
============================================================

Call Rows:

- GET /spreadsheets/GqOwXTcrQ9u14dbdcTxWa/tables/a2300cab-6557-4c6a-8e48-129b169bcc68/values/A2:B999

Interpret:
- column A (items[row][0])   = trigger key
- column B (items[row][1])   = JSON string

Find row where:
- items[row][0] == "blog-cp:2"

Parse items[row][1] → job_definition.

Minimal checks:
- job_definition.street == "blog"
- job_definition.house  == "cp:2"
- job_definition.run_order is array
- job_definition.datasets is non-empty
- job_definition.paths.docs_finals_root starts with "docs/"

If any check fails:
- STOP and reply with a short error message.
Else keep job_definition in memory.

============================================================
3. LOAD HOUSE FILES (cp:2)
============================================================

Use house_root from runner.txt:

- house_root = "items/blog/cp-2/"

Read (for internal use only):

- pipeline-spec.json
- style-spec.json
- expeditor-contract.json
- expeditor-map.json
- final-schema.json
- commit-spec.json
- checker.json
- member-template-cr.prompt
- member-template-cw.prompt
- member-template-pr.prompt
- member-template-pw.prompt
- member-template-rwt.prompt
- instructions.txt

If final-schema.json or any needed member-template is missing:
- STOP and tell user: house not fully configured.

No user messages yet.

============================================================
4. FETCH DATASETS (Rows)
============================================================

From job_definition.datasets, for each dataset:

- role_key
- domains
- sheet_id
- table_id
- range

Call Rows:

- GET /spreadsheets/{sheet_id}/tables/{table_id}/values/{range}

Store in memory:

- datasets_by_role[role_key] = {
    "role_key": role_key,
    "domains": domains,
    "items": <rows from Rows>
  }

If any dataset fetch fails:
- STOP and send a short error naming the failing role_key.

Still no progress updates to user.

============================================================
5. EXECUTE run_order IN MEMORY
============================================================

Let:

- run_order    = job_definition.run_order
- global_rules = job_definition.global_rules
- paths        = job_definition.paths

Maintain state:

- state.exp_output
- state.crr_output
- state.cwr_output
- state.prr_output
- state.pwr_output
- state.rwt_output

Loop through run_order, strictly in order:

5.1 exp
  - Input: job_definition, datasets_by_role, expeditor-* files, global_rules
  - Normalize null/empty → "could-not-verify"
  - Map roles/domains using expeditor-map.json
  - Output:
      state.exp_output = {
        "cr0_input": <JSON>,
        "pr1_input": <JSON>
      }

5.2 crr
  - Input: state.exp_output.cr0_input, global_rules, member-template-cr.prompt, instructions.txt
  - Output: state.crr_output (facts-only JSON for event/venue/city_season)

5.3 cwr
  - Input: state.crr_output, global_rules, member-template-cw.prompt, instructions.txt
  - Output: state.cwr_output (narrative JSON for competitions track)

5.4 prr
  - Input: state.exp_output.pr1_input, global_rules, member-template-pr.prompt, instructions.txt
  - Output: state.prr_output (facts-only JSON for stay/dine/essentials/locale)

5.5 pwr
  - Input: state.prr_output, global_rules, member-template-pw.prompt, instructions.txt
  - Output: state.pwr_output (narrative JSON for places track)

5.6 rwt
  - Input: state.cwr_output, state.pwr_output, final-schema.json, global_rules,
           member-template-rwt.prompt, instructions.txt
  - Responsibilities:
      - merge collection + places narratives
      - enforce final-schema.json
      - polish wording only
      - ensure no literal "could-not-verify" in visible text
  - Output: state.rwt_output (final JSON)

No user messages during any lane.

============================================================
6. COMMIT FINAL JSON + HTML + LOG
============================================================

From job_definition.paths:

- finals_root = job_definition.paths.docs_finals_root
  (e.g. "docs/blog/cp-2/finals/")
- logs_root   = job_definition.paths.docs_logs_root
  (e.g. "docs/blog/cp-2/logs/")
- job_id      = job_definition.job_id

Derive:

- json_path = finals_root + job_id + ".json"
- html_path = finals_root + job_id + ".html"
- log_path  = logs_root   + job_id + "-rwt.json"

Build:

- final_json  = JSON(state.rwt_output)

- html_output = HTML string rendering the main paragraphs, for example:

  <html>
    <body>
      <p>{{collection_body.paragraph_1}}</p>
      <p>{{collection_body.paragraph_2}}</p>

      <hr />

      <p>{{places_body.stay_paragraph}}</p>
      <p>{{places_body.dine_paragraph}}</p>
      <p>{{places_body.essentials_paragraph}}</p>
      <p>{{places_body.locale_paragraph}}</p>
      <p>{{places_body.outro_paragraph}}</p>
    </body>
  </html>

- log_json = JSON({
    "job_id": job_id,
    "run_order": run_order,
    "crr_output": state.crr_output,
    "cwr_output": state.cwr_output,
    "prr_output": state.prr_output,
    "pwr_output": state.pwr_output,
    "rwt_output": state.rwt_output
  })

Base64-encode all three and call docs_commit_bulk:

- message:   "Final commit for " + job_id
- overwrite: true
- files:
  - { path: json_path, content_type: "application/json", content_base64: <json> }
  - { path: html_path, content_type: "text/html",        content_base64: <html> }
  - { path: log_path,  content_type: "application/json", content_base64: <log_json> }

If commit fails:
- STOP and send a concise error to the user.


============================================================
7. USER RESPONSE (ONE MESSAGE)
============================================================

If everything succeeds:

- Send ONE summary message:
  - job_id
  - executed run_order
  - final JSON path
  - final HTML path
  - commit SHA (if returned)

If anything fails earlier:
- Send ONE concise error, naming:
  - failing phase (job load, datasets, lane name, commit)
  - minimal reason.

No step-by-step progress chatter; only final success or failure.
