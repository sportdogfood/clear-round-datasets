# File: items/blog/cp-2/instructions-mini.txt
# Runner: blog-cp:2 — MINI (end-to-end)
# Version: v2025-12-11-min-03

# PURPOSE
# - Trigger: "start blog-cp:2"
# - Load job_definition from Rows
# - Load cp:2 house files
# - Fetch datasets defined in job_definition
# - Run full run_order (exp → crr → cwr → prr → pwr → rwt) in memory
# - Commit FINAL JSON + HTML
# - Commit LANE LOGS for exp / crr / cwr / prr / pwr / rwt
# - Send ONE final success/failure summary to the user

============================================================
1. TRIGGER
============================================================

Accept only:

- start blog-cp:2

On anything else: do nothing.

Let:
- street_token = "blog"
- house_token  = "cp:2"

============================================================
2. LOAD job_definition (Rows)
============================================================

Call Rows:

- GET /spreadsheets/GqOwXTcrQ9u14dbdcTxWa/tables/a2300cab-6557-4c6a-8e48-129b169bcc68/values/A2:B999

Interpret:
- column A (items[row][0]) = trigger key
- column B (items[row][1]) = JSON string

Find row where:
- items[row][0] == "blog-cp:2"

Parse items[row][1] → job_definition.

Minimal checks:
- job_definition.street == "blog"
- job_definition.house  == "cp:2"
- job_definition.run_order is array
- job_definition.datasets is non-empty
- job_definition.paths.docs_finals_root starts with "docs/"
- job_definition.paths.docs_logs_root   starts with "docs/"

If any check fails:
- STOP and reply with a short error message.
Else keep job_definition in memory.

============================================================
3. LOAD HOUSE FILES (cp:2)
============================================================

Use house_root from runner.txt:

- house_root = "items/blog/cp-2/"

Read (for internal use only):

- pipeline-spec.json
- style-spec.json
- expeditor-contract.json
- expeditor-map.json
- final-schema.json
- commit-spec.json
- checker.json
- member-template-cr.prompt
- member-template-cw.prompt
- member-template-pr.prompt
- member-template-pw.prompt
- member-template-rwt.prompt
- instructions.txt

If final-schema.json or any needed member-template is missing:
- STOP and tell user: house not fully configured.

No user messages yet.

============================================================
4. FETCH DATASETS (Rows)
============================================================

From job_definition.datasets, for each dataset:

- role_key
- domains
- sheet_id
- table_id
- range

Call Rows:

- GET /spreadsheets/{sheet_id}/tables/{table_id}/values/{range}

Store in memory:

- datasets_by_role[role_key] = {
    "role_key": role_key,
    "domains": domains,
    "items": <rows from Rows>
  }

If any dataset fetch fails:
- STOP and send a short error naming the failing role_key.

Still no progress updates to user.

============================================================
5. EXECUTE run_order IN MEMORY
============================================================

Let:

- run_order    = job_definition.run_order
- global_rules = job_definition.global_rules
- paths        = job_definition.paths

Maintain state:

- state.exp_output
- state.crr_output
- state.cwr_output
- state.prr_output
- state.pwr_output
- state.rwt_output

Loop through run_order, strictly in order:

5.1 exp
  - Input: job_definition, datasets_by_role, expeditor-* files, global_rules
  - Normalize null/empty → "could-not-verify"
  - Map roles/domains using expeditor-map.json
  - Output:
      state.exp_output = {
        "cr0_input": <JSON>,
        "pr1_input": <JSON>
      }

5.2 crr
  - Input:
      state.exp_output.cr0_input,
      global_rules,
      member-template-cr.prompt,
      instructions.txt
  - Output:
      state.crr_output (facts-only JSON for event/venue/city_season)

5.3 cwr
  - Input:
      state.crr_output,
      global_rules,
      member-template-cw.prompt,
      instructions.txt
  - Output:
      state.cwr_output (narrative JSON for collection track)

5.4 prr
  - Input:
      state.exp_output.pr1_input,
      global_rules,
      member-template-pr.prompt,
      instructions.txt
  - Output:
      state.prr_output (facts-only JSON for stay/dine/essentials/locale)

5.5 pwr
  - Input:
      state.prr_output,
      global_rules,
      member-template-pw.prompt,
      instructions.txt
  - Output:
      state.pwr_output (narrative JSON for places track)

5.6 rwt
  - Input:
      state.cwr_output,
      state.pwr_output,
      final-schema.json,
      global_rules,
      member-template-rwt.prompt,
      instructions.txt
  - Responsibilities:
      - merge collection + places narratives
      - enforce final-schema.json
      - polish wording only
      - ensure no literal "could-not-verify" in visible text
  - Output:
      state.rwt_output (final JSON)

No user messages during any lane.

============================================================
6. COMMIT FINAL JSON + HTML + LOGS
============================================================

From job_definition.paths:

- finals_root = job_definition.paths.docs_finals_root
  (e.g. "docs/blog/cp-2/finals/")
- logs_root   = job_definition.paths.docs_logs_root
  (e.g. "docs/blog/cp-2/logs/")
- job_id      = job_definition.job_id

Derive FINAL paths:

- final_json_path = finals_root + job_id + ".json"
- final_html_path = finals_root + job_id + ".html"

Derive LOG paths:

- exp_log_path = logs_root + job_id + ".exp.json"
- crr_log_path = logs_root + job_id + ".crr.json"
- cwr_log_path = logs_root + job_id + ".cwr.json"
- prr_log_path = logs_root + job_id + ".prr.json"
- pwr_log_path = logs_root + job_id + ".pwr.json"
- rwt_log_path = logs_root + job_id + ".rwt.json"

Build FINAL artifacts:

- final_json   = JSON(state.rwt_output)
- html_output  = simple HTML page rendering the main paragraphs
                 (implementation defined in instructions.txt)

Build LOG artifacts (lane snapshots):

- exp_log_json = JSON(state.exp_output)
- crr_log_json = JSON(state.crr_output)
- cwr_log_json = JSON(state.cwr_output)
- prr_log_json = JSON(state.prr_output)
- pwr_log_json = JSON(state.pwr_output)
- rwt_log_json = JSON(state.rwt_output)

Base64-encode all bodies and call docs_commit_bulk using commit-spec.json
shape (effective payload):

- commit_message: "Final commit for " + job_id
- overwrite: true
- files:
  - { path: final_json_path,
      content_type: "application/json",
      content_base64: <final_json_base64> }
  - { path: final_html_path,
      content_type: "text/html",
      content_base64: <html_output_base64> }
  - { path: exp_log_path,
      content_type: "application/json",
      content_base64: <exp_log_base64> }
  - { path: crr_log_path,
      content_type: "application/json",
      content_base64: <crr_log_base64> }
  - { path: cwr_log_path,
      content_type: "application/json",
      content_base64: <cwr_log_base64> }
  - { path: prr_log_path,
      content_type: "application/json",
      content_base64: <prr_log_base64> }
  - { path: pwr_log_path,
      content_type: "application/json",
      content_base64: <pwr_log_base64> }
  - { path: rwt_log_path,
      content_type: "application/json",
      content_base64: <rwt_log_base64> }

If commit fails:
- STOP and send a concise error to the user.

============================================================
7. USER RESPONSE (ONE MESSAGE)
============================================================

If everything succeeds:

- Send ONE summary message containing at least:
  - job_id
  - executed run_order
  - final JSON path      (final_json_path)
  - final HTML path      (final_html_path)
  - log root             (logs_root)
  - commit SHA (if returned)

If anything fails earlier:
- Send ONE concise error, naming:
  - failing phase (job load, datasets, lane name, commit)
  - minimal reason.

No step-by-step progress chatter; only final success or failure.
