{
  "runner": "competition-runner",
  "version": "2.0.0",
  "notes": "Expeditor version. For each creation_id: read collections-payload + 3 prompts from Rows, run event/venue/city prompts in order, write 3 JSON files to /docs. No QA or stitching.",
  "io_contract": {
    "input": {
      "creation_id": "string, required. Example: 'creator-abc'."
    },
    "tools": {
      "rows": {
        "payload": {
          "operation_id": "getCompetitionPayloadRows",
          "endpoint": "/spreadsheets/GqOwXTcrQ9u14dbdcTxWa/tables/18be0a0d-dbea-43ea-811f-f7bcbf4982d3/values/A2:B999",
          "response": {
            "root_array_field": "items",
            "row_shape": [
              "creation_id",
              "payload_json_string"
            ],
            "selection_rule": "Find first row where row[0] == creation_id; parse row[1] as JSON into collections_payload; if none, stop with error."
          }
        },
        "prompts": {
          "operation_id": "getCompetitionPromptRows",
          "endpoint": "/spreadsheets/<PROMPT_SHEET_ID>/tables/<PROMPT_TABLE_ID>/values/A2:D999",
          "response": {
            "root_array_field": "items",
            "row_shape": [
              "creation_id",
              "event_prompt",
              "venue_prompt",
              "city_prompt"
            ],
            "selection_rule": "Find first row where row[0] == creation_id; map row[1] to event_prompt_raw, row[2] to venue_prompt_raw, row[3] to city_prompt_raw; if none, stop with error."
          }
        }
      },
      "crt": {
        "read": {
          "operation_id": "items_get",
          "paths": {
            "blueprint": "agents/competition-runner/competition-runner-instructions.json"
          }
        },
        "write": {
          "operation_id": "docs_commit_bulk",
          "paths": {
            "event": "docs/runner/competition-event.{creation_id}.json",
            "venue": "docs/runner/competition-venue.{creation_id}.json",
            "city": "docs/runner/competition-city.{creation_id}.json"
          },
          "content_type": "application/json"
        }
      }
    },
    "output": {
      "description": "Three independent JSON documents per creation_id, each generated by a single prompt and written to /docs.",
      "files": {
        "event": {
          "path_template": "docs/runner/competition-event.{creation_id}.json",
          "description": "Opaque JSON returned by the event prompt. Shape is defined entirely by the event prompt text (e.g., *-event JSON)."
        },
        "venue": {
          "path_template": "docs/runner/competition-venue.{creation_id}.json",
          "description": "Opaque JSON returned by the venue prompt (e.g., *-venue JSON)."
        },
        "city": {
          "path_template": "docs/runner/competition-city.{creation_id}.json",
          "description": "Opaque JSON returned by the city/season prompt (e.g., *-seasons JSON)."
        }
      }
    }
  },
  "collections_payload_contract": {
    "description": "Minimal expectations for collections_payload used only to fill dynamic pieces of the prompts. This version does not enforce any schema for the prompt outputs.",
    "fields": {
      "span_start_date": "string, optional; series-level start date.",
      "span_end_date": "string, optional; series-level end date.",
      "span_season": "string, optional; e.g. 'summer'.",
      "span_season_city_slug": "string, optional; e.g. 'summer-wellington'.",
      "span_rating": "string, optional; raw rating text.",
      "collection_primary": {
        "collection_uid": "string, optional.",
        "collection_title": "string, optional; base series name (e.g., 'ESP Summer').",
        "zoom_leg_name": "string, optional; highlighted leg name.",
        "zoom_start_date": "string, optional.",
        "zoom_end_date": "string, optional.",
        "zoom_season": "string, optional.",
        "zoom_season_city_slug": "string, optional.",
        "zoom_rating": "string, optional.",
        "comps": "array, optional; per-leg competition entries used only if the prompts reference leg counts or examples."
      }
    }
  },
  "prompt_execution": {
    "order": [
      "event",
      "venue",
      "city"
    ],
    "blocks": {
      "event": {
        "source_column": "event_prompt",
        "output_path_template": "docs/runner/competition-event.{creation_id}.json",
        "description": "The event prompt is stored as a complete text block in Rows (second column after creation_id). It should match the 'Use canvas. Create a new document titled <name>-event JSON...' style you already use. The runner does not rewrite the prompt; it may only substitute obvious placeholders (e.g., {{event_name}}) with values from collections_payload if such mapping is configured."
      },
      "venue": {
        "source_column": "venue_prompt",
        "output_path_template": "docs/runner/competition-venue.{creation_id}.json",
        "description": "Venue prompt (third column). Should match your existing '*-venue JSON' prompt. Runner treats it as opaque text, optionally substituting placeholders before sending to the model."
      },
      "city": {
        "source_column": "city_prompt",
        "output_path_template": "docs/runner/competition-city.{creation_id}.json",
        "description": "City/season prompt (fourth column). Should match your existing '*-seasons JSON' prompt. Runner forwards it directly to the model."
      }
    },
    "placeholder_substitution": {
      "strategy": "optional",
      "notes": "If your stored prompts contain tokens like {{event_name}}, {{city}}, {{state}}, {{span_start_date}}, etc., the runner MAY replace those tokens with values read from collections_payload before sending the prompt to the model. If no mapping is provided or a value is missing, the runner must leave the token unchanged and still proceed."
    }
  }
}
