Session timestamp: `2025-11-11T09:44:34-05:00` (America/New_York). Treat this as the anchor for this design pass.

Here is the consolidated standard. No code. No guesses.

---

## 1. Core goals

Single, tight system:

* Domain: show packing only.
* Scope: ≤10 active shows, ~20 horses, ~5 locations, ~10 lists, ~200 items.
* Interface: mobile-first, voice-first, zero-noise.
* Backend: JSON over `/items/*` for reads, `/items/commit*` for writes via your proxy.
* Brain: small-world assistant that:

  * only speaks “packing + inventory”,
  * uses your libs as truth,
  * rejects “weather / stocks / random” with “sorry, not my lane.”

Everything below is to make that precise and consistent.

---

## 2. Canonical entity layer (`lib/*.json`)

These are your “outside lane” truth tables.
They do not depend on workflow state.
They power recognition, validation, and voice understanding.

Shared shape across libs (plus domain-specific keys):

Common fields:

* `_active`: `true | false`
* `*_name`: canonical label (e.g. `show_name`, `horse_name`, `item_name`, etc.)
* `aliases`: `string[]`
* `misspells`: `string[]`
* `spanish_translate`: `string[] | string`
* `tags`: `string[]`
* `bin_home`: string or null
* `bin_away`: string or null
* `type`: string (coarse category)
* `sub_type`: string or null
* `_inactive_reason`: `"missing" | "broken" | "retired" | "moved" | "duplicate" | "manual" | null`
* `_inactive_at`: ISO timestamp or null
* `_created_by`: device/user label
* `_created_at`: ISO timestamp

Domain-specific:

1. `shows_lib.json`

   * `show_id`
   * `show_name`
   * `home_location_id` (staging / barn)
   * `away_location_id` (show grounds)
   * `start_date`, `end_date`
   * Optional: `default_lists` (e.g. `["tack","equipment","feed"]`)

2. `locations_lib.json`

   * `location_id`
   * `formatted_address`
   * `kind`: `"home" | "show" | "storage" | "other"`

3. `horses_lib.json`

   * `horse_id`
   * `horse_name`
   * `number` or show number
   * `owner`, `trainer` (optional)
   * `default_items`: `item_id[]` (Romeo’s saddle etc., optional)
   * `default_tags`: e.g. `["hunter"]`

4. `items_lib.json`

   * `item_id`
   * `item_name`
   * `for_horse_id` (nullable; set for Romeo-only gear)
   * `default_type` / `default_sub_type`
   * `unit`: `"each" | ...`
   * `per_horse`: boolean (for “1 per horse” logic)
   * `per_show`: number or null (flat qty per show)
   * `block_if_missing_or_broken`: boolean (for re-use rules)

5. `lists_lib.json`

   * `list_id`
   * `list_name` (tack, equipment, feed, etc.)
   * `purpose`: `"packing" | "feed" | "meds" | ...`
   * `default_scope`: e.g. `"per_show"`, `"per_horse"`, `"global"`

6. `kits_lib.json` (optional)

   * If you keep it: define “suggested bundles” only.
   * `kit_id`
   * `kit_name`
   * `items`: `item_id[]`
   * No magic. Pure suggestion surface. Core logic must not depend on kits.

All “intelligence” for names, nicknames, language, fuzzy mapping comes from these libs. That is the outside lane.

---

## 3. Runtime layer: packing workflow

This is where state lives.
Minimal, predictable.

Key runtime files (under `/items/agents/list-runner/`):

* `lists/started_lists.json`
* `lists/archived_lists.json`
* `lists/index.json` (derived summary)
* `state.json` (recent show, devices, etc.)
* `logs/updates.json` (append-only events)

### 3.1 Packing list = order / invoice analogy

For each show:

A “packing list” instance = one logical “order” with:

* `show_id` (from `shows_lib`)
* `home_location_id`, `away_location_id` (from libs)
* `horses`: `horse_id[]` attending this show
* `lists`: keyed by `list_id` or `list_name`

  * each list has:

    * `state`: `"home" | "away | "complete"`
    * `items`: array of line items

Line item fields (conceptual):

* `item_id` (if from `items_lib`)
* `name`
* `for_horse_id` (nullable)
* `qty_planned`
* `qty_packed_to_take`
* `qty_packed_to_return`
* `to_take`: `"not_packed" | "packed" | "not_needed"`
* `to_bring_home`: `"not_packed" | "packed" | "missing" | "broken" | "left_over" | "sent_back_early"`
* `bin_home`, `bin_away` (resolved from libs)
* `history`: [{ ts, action, by, from, to }]

Transitions:

* While list `state="home"`:

  * user marks `to_take`.
  * when all are `packed` or `not_needed` you can propose `mark list away`.
* While `state="away"`:

  * user marks `to_bring_home`.
  * when all resolved (`packed/missing/broken/left_over/sent_back_early`) you can propose `mark list complete`.
* No “in transit” state needed.
* Horse roster matters because:

  * horse-specific items only appear if that horse is in the show’s `horses[]`.
  * when a horse is “sent home early,” it just affects which items need to be present later, not the global mechanics.

You end up with:

> `thisList` contains `{thisItem, thatItem, romeos_saddle}`, plus metadata to know which belong to Romeo, which are global, and their pack/return states.

No kits required for correctness. Kits only pre-fill suggestions.

---

## 4. Transactions, adjustments, logs (thin but explicit)

You do not need full WMS complexity. You only need enough structure so nothing is “mystery teleported.”

Conceptual:

* `transactions` (internal representation or future file)

  * `type`: `"transfer" | "adjustment"`
  * `context`: show_id, list_id, location_from, location_to
  * `lines`: item_id, qty, reason
* `adjustments` are specific logs:

  * `damage`, `new`, `silent_missing`
* `logs/updates.json`:

  * single append-only event stream:

    * `list_new`, `list_archived`
    * `item_added`, `item_packed`, `item_status_change`
    * `item_inactive`, `item_inactive_reason`
    * etc.

You can derive history and reports without bloating the runtime schema.

---

## 5. Outside language lane

This is your intent + vocabulary brain.
It does not mutate workflow state directly.
It only helps map “what the human said” → clean commands that do.

Sources:

1. Lib fields:

   * `aliases`, `misspells`, `spanish_translate`, `tags` in all `*_lib.json`.
   * These cover items, horses, shows, lists, locations.

2. Intent lexicon (small JSON, e.g. `lang/intent_lib.json`):

   * Groups of verbs/phrases per intent:

     * `add_item`: “add”, “put”, “throw in”
     * `set_status`: “mark”, “set”, “call”
     * `bulk_pack_to_take`: “make sure everything is packed to go”, etc.
     * `bulk_pack_to_bring_home`: “make sure everything is ready to leave”, etc.
     * `show_list`, `summary`, `use_show`, etc.
   * This is where you encode:

     * “create a new list”
     * “mark romeos saddle packed”
     * “what is left to pack”
   * All strictly scoped to packing semantics.

3. Fuzzy + phonetic helpers:

   * You can load Fuse.js or similar in the client or a dedicated micro-service.
   * Apply only against:

     * ids/names/aliases from `*_lib.json`
     * known intents from `intent_lib`
   * No global web search. No guessing outside defined vocab.

Pipeline:

speech → ASR text → language lane:

* normalize (lowercase, strip filler)
* detect intent using `intent_lib`
* resolve entities using libs + fuzzy
* emit a small canonical command:

  * e.g. `mark {item_id} packed`, `show {list_id}`, `add {item_id} to {list_id}`

Then send that canonical command through your `/items/agents/list-runner/command` (once you define it) or directly via `/items/commit-bulk` wrappers.

---

## 6. Small-world assistant behavior

Rules:

1. Hard domain fence:

   * If input does not match:

     * known intents, or
     * known entities from libs,
   * respond with a short rejection:

     * “Sorry, I only handle show packing and gear.”
   * No drift into weather, news, etc.

2. Deterministic over creative:

   * Always prefer explicit entity matches from libs.
   * Use fuzzy only as tie-breaker, and if still ambiguous, ask:

     * “Blue saddle pad or white saddle pad?”
   * Never invent shows/horses/items.

3. External lane separation:

   * Language lane knows many phrases.
   * Only a tiny, stable set of canonical actions are allowed to hit data:

     * `add_item`, `set_status`, `bulk_pack`, `show_list`, `summary`, `switch_show`, etc.

This keeps it fast, safe, predictable.

---

## 7. Proxy + OpenAPI alignment

You already have a clean proxy:

* `GET /items/*` → reads from Git (via UPSTREAM_BASE)
* `POST /items/commit` → single-file write
* `POST /items/commit-bulk` → multi-file write
* `GET /docs/*`, `POST /docs/*` are unrelated to List-Runner.

Optimal usage for this design:

* Reads:

  * Assistant and expeditor use only `GET /items/agents/list-runner/...`
  * That includes:

    * libs: `lib/*.json`
    * runtime: `lists/*.json`, `state.json`, `logs/updates.json`
* Writes:

  * One commit-bulk per logical operation:

    * update `state.json`, `lists/started_lists.json`, `logs/updates.json`, and derived `lists/index.json` together.
  * No direct GitHub; only via your proxy.

OpenAPI:

* Only needs to expose the real, minimal surface:

  * `/health`
  * `/items/{path}` (GET)
  * `/items/commit` (POST)
  * `/items/commit-bulk` (POST)
  * (Optionally) `/items/agents/list-runner/command` once you define it, as the canonical NL → action endpoint.
* No references to `shows/show_schedule.json` or any removed legacy file unless you reintroduce them.

---

## 8. Preventing future drift

Concrete constraints to follow going forward:

1. All entity recognition must come from:

   * `shows_lib.json`
   * `locations_lib.json`
   * `horses_lib.json`
   * `items_lib.json`
   * `lists_lib.json`
   * `kits_lib.json` (if used)
   * `lang/intent_lib.json` (intent only)
2. Workflow state only in:

   * `lists/started_lists.json`
   * `lists/archived_lists.json`
   * `lists/index.json` (derived)
   * `state.json`
   * `logs/updates.json`
3. No code or logic may:

   * depend on nonexistent legacy files,
   * invent file paths,
   * reinterpret schema that is not explicitly defined.
4. Voice / NL:

   * runs entirely off the outside lane + intents,
   * outputs only whitelisted canonical commands into the runtime layer.

If you want next step text (not code): I can outline the exact JSON shapes for each lib and each runtime file so you can seed them cleanly.
